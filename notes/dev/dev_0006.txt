----------
13.10.2025
----------

Before starting work on v0.3 features
let's first do all TO-DO items

{
First TO-DO item is:
    Create a mechanism in Core where client code can register a callback function
    to be called every N seconds automatically. Use it for Gleam House's updateFireColors() function, for example.

1. This mechanism will work on an application level so we need some API in class PekanApplication
for registering a callback function to be called repeatedly automatically by Pekan.
Let's call such callback a "recurring callback" and let's create a new public function in PekanApplication:
    void registerRecurringCallback(std::function<void()> callback, float interval);
2. Internally, to store a list of such recurring callbacks we'll create a new struct
    struct RecurringCallback
in 2 new files in Core
    Time/RecurringCallback.h
    Time/RecurringCallback.cpp
It will, of course, store the callback function and the time interval between calls:
    std::function<void()> callback;        
    float interval = 0.0f;
but it will also store the elapsed time since last call
    float elapsed = 0.0f;
3. Then in PekanApplication we can have a vector of such recurring callbacks:
    std::vector<RecurringCallback> m_recurringCallbacks;
and, of course, in registerRecurringCallback() we will create a new RecurringCallback instance
from the given parameters and push it into the m_recurringCallbacks list,
or more directly we will use emplace_back:
    m_recurringCallbacks.emplace_back(std::move(callback), interval);
4. In PekanApplication's main loop which is in the run() function we'll need to
update all registered recurring callbacks. Let's create a function in PekanApplication for that:
    void updateRecurringCallbacks(float deltaTime);
It needs to loop over all registered recurring callbacks
    for (RecurringCallback& recurringCallback : m_recurringCallbacks)
and increase the elapsed time of each one with current frame's delta time:
    recurringCallback.elapsed += deltaTime;
If a recurring callback's interval elapses we need to call the actual callback
and reset the elapsed time to 0:
    if (recurringCallback.elapsed >= recurringCallback.interval)
    {
        recurringCallback.callback();
        recurringCallback.elapsed = 0.0f;
    }
5. That's it.
Tested it in Demo07 by creating 2 new member functions in Demo07_Scene
    void changeBackgroundColor();
    void changeRectangleColor();
that change background's color and rectangle's color, just switching it between 2 hardcoded colors.
Then in Demo07_Scene we can register these 2 functions as recurring callbacks in m_application:
    m_application->registerRecurringCallback
    (
        [this]() { this->changeBackgroundColor(); },
        1.0f
    );
    m_application->registerRecurringCallback
    (
        [this]() { this->changeRectangleColor(); },
        0.4f
    );
It works!

Done.
}

----------
15.10.2025
----------

{
Next TO-DO item is:
    Create a getRandomColor() overload in PekanUtils.h/cpp that takes in an RGB range where R, G and B's min/max can be different.

Now looking at
    PekanUtils.h
    PekanUtils.cpp
all functions there are for generating random stuff,
so let's rename these files to
    RandomizationUtils.h
    RandomizationUtils.cpp

Let's create 2 new functions for generating a random color:
    glm::vec4 getRandomColor(glm::vec3 rgbMin, glm::vec3 rgbMax, bool randomizeAlpha = false);
    glm::vec4 getRandomColor(glm::vec4 rgbaMin, glm::vec4 rgbaMax);
Done. Easy.
Also noticed the API is not very consistent across functions in this file,
so I changed all functions to take in min/max, NOT xRange, yRange, etc.
Nothing important about this change, it's just for consistency.

Done.
}

----------
17.10.2025
----------

{
Next TO-DO item is:
    Remove "static" from "static const" and "static constexpr" everywhere
    where used for global variables that are constant, defined in a single .cpp, and not supposed to be visible outside.
    It's redundant. Global constants have internal linkage by default.

Okay, done.
Went through the whole codebase, checked the usage of all "static const" occurrences
and removed "static" from the ones that are global variables.

Also, did an additional thing.
Changed "const" to "constexpr" everywhere where the data is known at compile time, for example:
    constexpr float COLOR_DULLNESS = 0.9f;
or
    constexpr char* const VERTEX_SHADER_FILEPATHS[] =
    {
        "resources/04_00_vertex_shader.glsl",
        "resources/04_01_vertex_shader.glsl",
        "resources/04_02_vertex_shader.glsl",
        "resources/04_03_vertex_shader.glsl"
    };
If data is NOT known at compile time then we must use "const" and NOT "constexpr", for example:
    const float cameraDist = m_guiWindow->getCameraDist();
or
    const int posX = int(INITIAL_POSITION_X * m_resolution.x);

While, we're at it, let's do another similar thing.
Let's remove "inline" from all functions defined inside a class.
It's not needed.
We only need "inline" if a function is defined outside a class but in the header file.
There is only one place that does this, and it's this function:
    inline std::ostream& operator<<(std::ostream& os, const Event& e)
    {
        return os << e.toString();
    }
in
    Event.h
so we'll keep this one as inline.
Removed all other instance of "inline".

Done.
}

----------
20.10.2025
----------

{
Next TO-DO item is
    Use
        inline static const
    everywhere to define static const member variables inside the class, instead of separately in the .cpp

Done.
}

----------
21.10.2025
----------

All TO-DO items are done now.

{
Time to start implementing v0.3 features.
I'll start with
    Entity Component System (ECS)

Decided to use a third party Entity Component System
because it's quite important that it's fast and reliable.
In the future we might implement our own ECS,
but for now let's integrate a third party one into Pekan
and see how exactly we want to use it.
After the usage of our ECS is clear we might reconsider and implement our own
or we might stick with the third party one, we'll see.

We will use
    EnTT
which is a free and open-source header-only ECS library for C++.
A good resource to get an idea of how to use EnTT and how to integrate it in a game engine
is, of course, The Cherno's Game Engine series.

First step would be to actually get EnTT and make it be a part of our project.
We'll get it as a git submodule. To do that, modify
    .gitmodules
appending this:
    [submodule "dep/entt"]
        path = dep/entt
        url = https://github.com/skypjack/entt.git
Then, to actually download the EnTT repository under
    dep/entt
we need to run
    git submodule update --init --recursive
(This, of course, will also have to be done on a freshly downloaded Pekan as well)

Now that we have the EnTT library under
    dep/entt
we need to set it up in CMake.
EnTT is a single-header library so we just need to be able to include this one header file:
    dep/entt/single_include/entt/entt.hpp
We can add this directory
    dep/entt/single_include
to Core's include directories in
    CMakeLists.txt
That way, we can include the header in our C++ files like this:
    #include <entt/entt.hpp>

To test if EnTT is setup correctly
let's include the header file in
    PekanApplication.cpp
and do a small test in PekanApplication::init()
We'll create an entt registry
    entt::registry registry;
Create 2 dummy structs that we'll use as components
    struct Position { float x, y; };
    struct Velocity { float vx, vy; };
Create an entity
    entt::entity e1 = registry.create();
and add the 2 components Position and Velocity to it with some values for x, y and vx, vy
    registry.emplace<Position>(e1, 1.0f, 2.0f);
    registry.emplace<Velocity>(e1, 0.1f, 0.2f);
Create another entity
    entt::entity e2 = registry.create();
and add just 1 of the components - Position - to it with some values for x, y
    registry.emplace<Position>(e2, 3.0f, 4.0f);
Then, we can get a "view" of all Position components in our registry, like this:
    registry.view<Position>()
and we can ask the size of this view
    const size_t posCount = registry.view<Position>().size();
which will give us the number of Position components in the registry: in this case 2
We can do the same for the Velocity components - get a "view" of them, and ask for its size:
    const size_t velCount = registry.view<Velocity>().size();
That's it.
Now we can debug and/or log the values of posCount and velCount
to make sure that they are 2 and 1, and indeed, they are.
It works!

We succesfully set up EnTT in Pekan!

Done.
}
