----------
13.10.2025
----------

Before starting work on v0.3 features
let's first do all TO-DO items

{
First TO-DO item is:
    Create a mechanism in Core where client code can register a callback function
    to be called every N seconds automatically. Use it for Gleam House's updateFireColors() function, for example.

1. This mechanism will work on an application level so we need some API in class PekanApplication
for registering a callback function to be called repeatedly automatically by Pekan.
Let's call such callback a "recurring callback" and let's create a new public function in PekanApplication:
    void registerRecurringCallback(std::function<void()> callback, float interval);
2. Internally, to store a list of such recurring callbacks we'll create a new struct
    struct RecurringCallback
in 2 new files in Core
    Time/RecurringCallback.h
    Time/RecurringCallback.cpp
It will, of course, store the callback function and the time interval between calls:
    std::function<void()> callback;        
    float interval = 0.0f;
but it will also store the elapsed time since last call
    float elapsed = 0.0f;
3. Then in PekanApplication we can have a vector of such recurring callbacks:
    std::vector<RecurringCallback> m_recurringCallbacks;
and, of course, in registerRecurringCallback() we will create a new RecurringCallback instance
from the given parameters and push it into the m_recurringCallbacks list,
or more directly we will use emplace_back:
    m_recurringCallbacks.emplace_back(std::move(callback), interval);
4. In PekanApplication's main loop which is in the run() function we'll need to
update all registered recurring callbacks. Let's create a function in PekanApplication for that:
    void updateRecurringCallbacks(float deltaTime);
It needs to loop over all registered recurring callbacks
    for (RecurringCallback& recurringCallback : m_recurringCallbacks)
and increase the elapsed time of each one with current frame's delta time:
    recurringCallback.elapsed += deltaTime;
If a recurring callback's interval elapses we need to call the actual callback
and reset the elapsed time to 0:
    if (recurringCallback.elapsed >= recurringCallback.interval)
    {
        recurringCallback.callback();
        recurringCallback.elapsed = 0.0f;
    }
5. That's it.
Tested it in Demo07 by creating 2 new member functions in Demo07_Scene
    void changeBackgroundColor();
    void changeRectangleColor();
that change background's color and rectangle's color, just switching it between 2 hardcoded colors.
Then in Demo07_Scene we can register these 2 functions as recurring callbacks in m_application:
    m_application->registerRecurringCallback
    (
        [this]() { this->changeBackgroundColor(); },
        1.0f
    );
    m_application->registerRecurringCallback
    (
        [this]() { this->changeRectangleColor(); },
        0.4f
    );
It works!

Done.
}

----------
15.10.2025
----------

{
Next TO-DO item is:
    Create a getRandomColor() overload in PekanUtils.h/cpp that takes in an RGB range where R, G and B's min/max can be different.

Now looking at
    PekanUtils.h
    PekanUtils.cpp
all functions there are for generating random stuff,
so let's rename these files to
    RandomizationUtils.h
    RandomizationUtils.cpp

Let's create 2 new functions for generating a random color:
    glm::vec4 getRandomColor(glm::vec3 rgbMin, glm::vec3 rgbMax, bool randomizeAlpha = false);
    glm::vec4 getRandomColor(glm::vec4 rgbaMin, glm::vec4 rgbaMax);
Done. Easy.
Also noticed the API is not very consistent across functions in this file,
so I changed all functions to take in min/max, NOT xRange, yRange, etc.
Nothing important about this change, it's just for consistency.

Done.
}

----------
17.10.2025
----------

{
Next TO-DO item is:
    Remove "static" from "static const" and "static constexpr" everywhere
    where used for global variables that are constant, defined in a single .cpp, and not supposed to be visible outside.
    It's redundant. Global constants have internal linkage by default.

Okay, done.
Went through the whole codebase, checked the usage of all "static const" occurrences
and removed "static" from the ones that are global variables.

Also, did an additional thing.
Changed "const" to "constexpr" everywhere where the data is known at compile time, for example:
    constexpr float COLOR_DULLNESS = 0.9f;
or
    constexpr char* const VERTEX_SHADER_FILEPATHS[] =
    {
        "resources/04_00_vertex_shader.glsl",
        "resources/04_01_vertex_shader.glsl",
        "resources/04_02_vertex_shader.glsl",
        "resources/04_03_vertex_shader.glsl"
    };
If data is NOT known at compile time then we must use "const" and NOT "constexpr", for example:
    const float cameraDist = m_guiWindow->getCameraDist();
or
    const int posX = int(INITIAL_POSITION_X * m_resolution.x);

While, we're at it, let's do another similar thing.
Let's remove "inline" from all functions defined inside a class.
It's not needed.
We only need "inline" if a function is defined outside a class but in the header file.
There is only one place that does this, and it's this function:
    inline std::ostream& operator<<(std::ostream& os, const Event& e)
    {
        return os << e.toString();
    }
in
    Event.h
so we'll keep this one as inline.
Removed all other instance of "inline".

Done.
}

----------
20.10.2025
----------

{
Next TO-DO item is
    Use
        inline static const
    everywhere to define static const member variables inside the class, instead of separately in the .cpp

Done.
}

----------
21.10.2025
----------

All TO-DO items are done now.

{
Time to start implementing v0.3 features.
I'll start with
    Entity Component System (ECS)

Decided to use a third party Entity Component System
because it's quite important that it's fast and reliable.
In the future we might implement our own ECS,
but for now let's integrate a third party one into Pekan
and see how exactly we want to use it.
After the usage of our ECS is clear we might reconsider and implement our own
or we might stick with the third party one, we'll see.

We will use
    EnTT
which is a free and open-source header-only ECS library for C++.
A good resource to get an idea of how to use EnTT and how to integrate it in a game engine
is, of course, The Cherno's Game Engine series.

First step would be to actually get EnTT and make it be a part of our project.
We'll get it as a git submodule. To do that, modify
    .gitmodules
appending this:
    [submodule "dep/entt"]
        path = dep/entt
        url = https://github.com/skypjack/entt.git
Then, to actually download the EnTT repository under
    dep/entt
we need to run
    git submodule update --init --recursive
(This, of course, will also have to be done on a freshly downloaded Pekan as well)

Now that we have the EnTT library under
    dep/entt
we need to set it up in CMake.
EnTT is a single-header library so we just need to be able to include this one header file:
    dep/entt/single_include/entt/entt.hpp
We can add this directory
    dep/entt/single_include
to Core's include directories in
    CMakeLists.txt
That way, we can include the header in our C++ files like this:
    #include <entt/entt.hpp>

To test if EnTT is setup correctly
let's include the header file in
    PekanApplication.cpp
and do a small test in PekanApplication::init()
We'll create an entt registry
    entt::registry registry;
Create 2 dummy structs that we'll use as components
    struct Position { float x, y; };
    struct Velocity { float vx, vy; };
Create an entity
    entt::entity e1 = registry.create();
and add the 2 components Position and Velocity to it with some values for x, y and vx, vy
    registry.emplace<Position>(e1, 1.0f, 2.0f);
    registry.emplace<Velocity>(e1, 0.1f, 0.2f);
Create another entity
    entt::entity e2 = registry.create();
and add just 1 of the components - Position - to it with some values for x, y
    registry.emplace<Position>(e2, 3.0f, 4.0f);
Then, we can get a "view" of all Position components in our registry, like this:
    registry.view<Position>()
and we can ask the size of this view
    const size_t posCount = registry.view<Position>().size();
which will give us the number of Position components in the registry: in this case 2
We can do the same for the Velocity components - get a "view" of them, and ask for its size:
    const size_t velCount = registry.view<Velocity>().size();
That's it.
Now we can debug and/or log the values of posCount and velCount
to make sure that they are 2 and 1, and indeed, they are.
It works!

We succesfully set up EnTT in Pekan!

Done.
}

----------
22.10.2025
----------

{
Let's continue with ECS now.
My idea for the next step is to implement a new class
    class Scene
that derives from class Layer
and has its own Entity Component System registry, which is this:
    entt::registry
Inside a scene client code will be able to create entities
and assign them different components.
Still not sure how and where we would implement the systems, but we'll see.

Let's start from somewhere.
Create an new class derived from class Layer
    class Scene : public Layer
in 2 new files in Core
    Scene.h
    Scene.cpp
We need just 2 things inside the class for now:
First, the constructor - class Scene needs to only be able to be constructed with an application pointer,
same way as the underlying Layer:
    Scene(PekanApplication* application) : Layer(application) {}
Second, we need to implement the getLayerName() function because it's pure virtual in class Layer
    virtual std::string getLayerName() const override { return "scene_layer"; }
Scene layers will be called
    "scene_layer"
by default. Client code can override this and provide another name.

Let's also create a new demo
as a playground where we can test the ECS while developing it.
Created
    Demo09
in a standard way, copied from Demo00
but removed everything from
    class Demo09_Scene
and made it derive from our new Scene class
    class Demo09_Scene : public Pekan::Scene
Only thing left in the class is the constructor:
    Demo09_Scene(Pekan::PekanApplication* application) : Pekan::Scene(application) {}
}

----------
23.10.2025
----------

{
Continuing with ECS.
The goal now is:
1. Change our Transformable2D class to be a component
2. Change our Sprite class to be a component
3. Create an entity with a Sprite component in Demo09

For 1. we'll need to separate Transformable2D into 2 new classes (or a struct and a class):
    struct TransformComponent2D
    class TransformSystem2D
into these 3 new files:
    TransformComponent2D.h
    TransformSystem2D.h
    TransformSystem2D.cpp
In simple terms we need TransformComponent2D to hold a transform's data
and TransformSystem2D to provide functionality for operating on that data.
It's good to keep components as minimal as possible,
so our TransformComponent2D will only have these 4 members:
    glm::vec2 position = { 0.0f, 0.0f };
    float rotation = 0.0f;
    glm::vec2 scale = { 1.0f, 1.0f };
    entt::entity parent = entt::null;
Let's not worry about optimization for now, and get rid of all "dirty flag" optimizations and caches.
Later we might bring them back but they will probably operate a bit differently in ECS.
(Created a TO-DO item for bringing them back)
Then, in TransformSystem2D we need to have functions that operate on entities that have a TransformComponent2D.
We'll keep those as simple as possible.
For now we only need getters and setters for position, rotation and scale,
and a getter for world matrix:
    static glm::vec2 getPosition(const entt::registry& registry, entt::entity entity);
    static float getRotation(const entt::registry& registry, entt::entity entity);
    static glm::vec2 getScale(const entt::registry& registry, entt::entity entity);
    static void setPosition(entt::registry& registry, entt::entity entity, glm::vec2 position);
    static void setRotation(entt::registry& registry, entt::entity entity, float rotation);
    static void setScale(entt::registry& registry, entt::entity entity, glm::vec2 scale);
    static glm::mat3 getWorldMatrix(const entt::registry& registry, entt::entity entity);
Just for completeness let's also add move(), rotate() and scale() as we had in Transformable2D:
    static void move(entt::registry& registry, entt::entity entity, glm::vec2 deltaPosition);
    static void rotate(entt::registry& registry, entt::entity entity, float deltaRotation);
    static void scale(entt::registry& registry, entt::entity entity, glm::vec2 deltaScale);

Okay, now we have a component and a system
that can be used by both our code and client code.
But to use them we need a registry.
Where is this registry going to live?
In the scene, of course.
Every scene will have its own ECS registry.
So let's add an entt::registry to our Scene class, as a private member:
    entt::registry m_registry;
together with protected getters (const and non-const):
    entt::registry& getRegistry() { return m_registry; }
    const entt::registry& getRegistry() const { return m_registry; }
Now scene classes that derive from Scene can access this registry
and use it together with our new TransformComponent2D and TransformSystem2D classes.
We'll need one more thing in class Scene:
(we don't strictly need it if we're being 100% minimal, but we'll add it for convenience)
We need protected functions for creating and destroying an entity:
    entt::entity createEntity();
    void destroyEntity(entt::entity entity);
Now derived scenes can easily create and destroy entities
and they can access the registry and use it together with components and systems provided by Pekan,
or with their own.

Let's do an example in Demo09.
We'll use a turkey texture for our sprite later on, so let's have an entity called
    entt::entity m_turkey;
in Demo09_Scene and let it have a default value of null
    entt::entity m_turkey = entt::null;
Then in Demo09_Scene's init() function we can create the turkey entity like this:
    m_turkey = createEntity();
and we can add a TransformComponent2D component to it like this:
    registry.emplace<TransformComponent2D>(m_turkey);
where on a previous line we get registry like this:
    entt::registry& registry = getRegistry();
If we want our turkey to be initialized with some initial position, not just at (0, 0), we can do this:
    registry.emplace<TransformComponent2D>(m_turkey, TURKEY_INITIAL_POSITION);
where TURKEY_INITIAL_POSITION is a global constexpr:
    constexpr glm::vec2 TURKEY_INITIAL_POSITION = glm::vec2(-0.5f, -0.2f);
Then in the update() function we can move the turkey slightly, like this:
    TransformSystem2D::move(registry, m_turkey, glm::vec2(0.02f, 0.01f));
Finally, to verify that everything works we can get turkey's world matrix:
    const glm::mat3 turkeyMatrix = TransformSystem2D::getWorldMatrix(registry, m_turkey);
and log it with PK_LOG_INFO so that we can see the world matrix every frame,
and we can see how it changes as turkey moves.
It works!

----------
24.10.2025
----------

{
    Before continuing with ECS let's remove this CMake option
        PEKAN_USE_1D_TEXTURE_FOR_2D_SHAPES_BATCH
    It will simplify things a lot. We might bring it back later on, or not (it was not very needed to begin with).
    We'll keep code as if the option is on.
    Done.
}

----------
25.10.2025
----------

For 2. we'll need to bypass RenderBatch2D and directly render our sprites.
Later we must think about bringing back RenderBatch2D and making it part of ECS
but for now we can't bother with that, we must first implement Sprite rendering
and then Shape rendering in the most straightforward way possible,
and only then bring back RenderBatch2D (or an alternative).

Let's implement a sprite component and a sprite system now.
We'll have 3 new files
    SpriteComponent.h
    SpriteSystem.h
    SpriteSystem.cpp
same as how we did with transform component and system.
First, we'll have a struct
    struct SpriteComponent
that contains only the data of a sprite.
A sprite needs width, height, a texture, and min/max of texture coordinates.
So the struct will consists of:
    float width = 0.0f;
    float height = 0.0f;
    Graphics::Texture2D_ConstPtr texture;
    glm::vec2 textureCoordinatesMin = { 0.0f, 0.0f };
    glm::vec2 textureCoordinatesMax = { 1.0f, 1.0f };
That's it. Simple as that.
Then we'll have a class
    class SpriteSystem
that will provide functionality over sprite components.
What functionality do we need?
Rendering.
That's all we need. We need to be able to render an entity with a sprite component.
    static void render(const entt::registry& registry, entt::entity entity);
The complicated part is what this function will do internally, but externally it's dead simple, just render().
So let's see how to implement this render function.
We said that we'd bypass RenderBatch2D for now and directly render sprites then and there.
So in this render function we will need to construct sprite's world vertices
taking into account the SpriteComponent, obviously, but also the TransformComponent2D.
Then once we have sprite's world vertices we'll need to create a render object with them,
provide an appropriate shader and index data,
and use SpriteComponent's texture.
That's the basic plan.
Implementing it is not that hard.
{
    Before proceeding to the implementation though let's think about
    what data structure we'll use for sprite's world vertices.
    Until now we used
        Vertex2D
    but this is a struct specifically targeted for batch rendering of sprites AND shapes together.
    We'll not be doing this for now, so let's have a new struct
        struct SpriteVertex
    in a new file
        SpriteVertex.h
    and let it contain only the data needed for a sprite vertex (no batch metadata, no shape data):
        glm::vec2 position = { -1.0f, -1.0f };
        glm::vec2 textureCoordinates = { -1.0f, -1.0f };
    That's it. That's our SpriteVertex that we'll use in SpriteSystem.
}
We first need to extract the SpriteComponent and TransformComponent2D from the given entity:
    const SpriteComponent& sprite = registry.get<SpriteComponent>(entity);
    const TransformComponent2D& transform = registry.get<TransformComponent2D>(entity);
Before that we can assert that entity exists and it has those 2 components:
    PK_ASSERT(registry.valid(entity), "Trying to render an entity that doesn't exist.", "Pekan");
    PK_ASSERT(registry.all_of<SpriteSystem>(entity), "Trying to render an entity that doesn't have a SpriteComponent component.", "Pekan");
    PK_ASSERT(registry.all_of<TransformComponent2D>(entity), "Trying to render an entity that doesn't have a TransformComponent2D component.", "Pekan");
Once we have entity's SpriteComponent and TransformComponent2D we will create a RenderObject out of them.
For that we'll have a helper function that we'll use like this:
    RenderObject renderObject;
    createRenderObjectForSprite(registry, sprite, transform, 0, renderObject);
The hardcoded 0 is the texture slot that we want the uniform inside the shader to be set to.
And on the next line we'll bind sprite's texture to this same slot 0
    sprite.texture->bind(0);
Finally, we need to render the render object
    renderObject.render();
That's the end of SpriteSystem::render()
Let's look at the implementation of
    createRenderObjectForSprite()
First we need to create world vertices out of sprite's components:
    SpriteVertex verticesWorld[4];
    getVerticesWorld(registry, sprite, transform, verticesWorld);
Again using a helper function for that:
    getVerticesWorld()
Then we create the render object from the world vertices in a pretty standard way:
    renderObject.create
    (
        verticesWorld,
        sizeof(SpriteVertex) * 4,
        {
            { ShaderDataType::Float2, "position" },
            { ShaderDataType::Float2, "textureCoordinates" }
        },
        BufferDataUsage::DynamicDraw,
        FileUtils::readTextFileToString(VERTEX_SHADER_FILEPATH).c_str(),
        FileUtils::readTextFileToString(FRAGMENT_SHADER_FILEPATH).c_str()
    );
We know that a sprite will always have 4 vertices so we can hardcode this
    sizeof(SpriteVertex) * 4
and we know the exact vertex layout
    {
        { ShaderDataType::Float2, "position" },
        { ShaderDataType::Float2, "textureCoordinates" }
    }
As for the 2 shaders they are these 2 new shaders:
    #define VERTEX_SHADER_FILEPATH PEKAN_RENDERER2D_ROOT_DIR "/Shaders/2D_Sprite_VertexShader.glsl"
    #define FRAGMENT_SHADER_FILEPATH PEKAN_RENDERER2D_ROOT_DIR "/Shaders/2D_Sprite_FragmentShader.glsl"
that I got from
    2D_Batch_VertexShader.glsl
    2D_Batch_FragmentShader.glsl
by removing batch metadata and shape data, and leaving only sprite rendering.
Once we have created the render object we need to set index data to it:
    static constexpr unsigned indices[6] = { 0, 1, 2, 0, 2, 3 };
    renderObject.setIndexData(indices, sizeof(unsigned) * 6);
That's easy because a sprite's index data is always the same - 0, 1, 2, 0, 2, 3 - just forming a rectangle out of 2 triangles.
And finally we need to set render object's shader's uniforms.
More specifically we need to set
    uniform mat4 uViewProjectionMatrix;
and
    uniform sampler2D uTexture;
To set the view projection matrix we'll use the currently active camera in Renderer2DSystem:
    Camera2D_ConstPtr camera = Renderer2DSystem::getCamera();
    setViewProjectionMatrixUniform(shader, camera);
using a helper function
    setViewProjectionMatrixUniform()
which is the same one from RenderBatch2D.cpp,
it gets camera's view projection matrix and sets uniform to it, unless camera is null then it sets default identity matrix.
To set the "uTexture" uniform we just set it to the given texture slot, easy as that:
    shader.setUniform1i("uTexture", textureSlot);
That's it.
Our SpriteSystem now supports rendering of entities that have both SpriteComponent and TransformComponent2D.

{
    Side note, until now we had this strict create()/destroy() or init()/exit() logic going on
    with mouse of our classes, which was very good for the more OOP design that we had,
    but now with ECS it doesn't make that much sense.
    Specifically, we don't want to manually call destroy() on things, we want it to be okay for them
    to just go out of scope and get destroyed automatically.
    So, what we need for now in this direction is to allow destructors to call destroy()
    instead of asserting that the object is not valid.
    Most of our classes in Graphics do this. It looks like:
        VertexBuffer::~VertexBuffer()
        {
            PK_ASSERT(!isValid(), "You forgot to destroy() a VertexBuffer instance.", "Pekan");
        }
    TL;DR we need to change destructors to do this instead:
        VertexBuffer::~VertexBuffer()
        {
            if (isValid())
            {
                destroy();
            }
        }
    Done.
}

Client code can now just call
    SpriteSystem::render()
for each entity that it wants to render in its scene's render() function,
but it will definitely be better that this rendering happens automatically.
What I mean is that all sprite entities that exist in client's scene
must get rendered automatically (unless specified otherwise, we might make an option like this later)
How to do that?
We can have another render() function in SpriteSystem that renders a whole ECS registry
    static void render(const entt::registry& registry);
That's a perfect use case to utilize the power of ECS.
We can very easily get a view of all entities in the registry that have SpriteComponent and TransformComponent2D:
    const auto view = registry.view<SpriteComponent, TransformComponent2D>();
and then just render each one of them with the already implemented render() function:
    for (entt::entity entity : view)
    {
        render(registry, entity);
    }
Now that we have this, client code can just do this in their render function:
    SpriteSystem::render(getRegistry());
and render all of their sprite entities.

We can do slightly better.
Let's have a new class
    class Scene2D
in 2 new files
    Scene2D.h
    Scene2D.cpp
in module Renderer2D.
This new Scene2D class will inherit from Scene, of course:
    class Scene2D : public Scene
and it will override the render function
    void render() const override;
with automatically calling SpriteSystem::render() on the scene's registry:
    const entt::registry& registry = getRegistry();
    SpriteSystem::render(registry);
We can also make it always clear the window before that:
    RenderCommands::clear();
(it's not technically correct to clear in every scene, because we might have more than one scene)
(we only need this temporarily until TO-DO item 0071 is done)
And to allow some flexibility on the render logic we'll provide a virtual function
    virtual void _render() const {}
that client code can choose to override with custom rendering logic that will be done ON TOP OF Scene2D's render logic,
so we need to call _render() in render() after doing the other stuff
    _render();
That's it.
Now we can make Demo09_Scene derive from Scene2D instead of Scene
and remove the render() function, and we have sprite entities being rendered by default.

Also did 3. didn't even notice, but yeah, we've got a working example in Demo09.

Done.
}
