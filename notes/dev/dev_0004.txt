----------
03.04.2025
----------

Officially starting work on v0.2.
Let's follow the list of features in
    plan_0004.txt

{
Let's tart with the event system. That's a big one.
I will use the following commits from Hazel Engine as reference.
    https://github.com/TheCherno/Hazel/commit/34df41651fe88041540f20df845a70642359dc17
    https://github.com/TheCherno/Hazel/commit/30516ad7109b016213eb732f14e1c7061c1db603

As a first step I will copy most of it, and just integrate it into Pekan,
to see how it works and to see if I like it.

Let's create a new directory
    Events
under
    src/PekanCore
Inside of it create the following header files
    WindowEvent.h
    Event.h
    KeyEvent.h
    MouseEvent.h
Add them to project PekanCore in the root CMake file.
Now I will copy code from the corresponding files in this Hazel commit
    https://github.com/TheCherno/Hazel/commit/34df41651fe88041540f20df845a70642359dc17
and integrate it into Pekan.
Done.

Now we have all relevant event types as classes.
Let's implement the actual event system using those classes.
The bottomline is we need to call these GLFW functions in PekanEngine
    glfwSetKeyCallback(s_window, ...);
    glfwSetCursorPosCallback(s_window, ...);
    glfwSetScrollCallback(s_window, ...);
    glfwSetMouseButtonCallback(s_window, ...);
    glfwSetWindowSizeCallback(s_window, ...);
    glfwSetWindowCloseCallback(s_window, ...);
and pass some appropriate functions as second parameters.
The functions that we will pass there will be called whenever an event of the given type occurs.

Let's create a new class
    EventHandler
in
    Event.h
and create static functions that we will use to pass as seconds parameters to the GLFW functions
    static void handleKeyEvent(GLFWwindow* window, int key, int scancode, int action, int mods);
    static void handleMouseMovedEvent(GLFWwindow* window, double xPos, double yPos);
    static void handleMouseScrolledEvent(GLFWwindow* window, double xOffset, double yOffset);
    static void handleMouseButtonEvent(GLFWwindow* window, int button, int action, int mods);
    static void handleWindowResizedEvent(GLFWwindow* window, int width, int height);
    static void handleWindowClosedEvent(GLFWwindow* window);
Then we can do this in PekanEngine.cpp
    glfwSetKeyCallback(s_window, EventHandler::handleKeyEvent);
    glfwSetCursorPosCallback(s_window, EventHandler::handleMouseMovedEvent);
    glfwSetScrollCallback(s_window, EventHandler::handleMouseScrolledEvent);
    glfwSetMouseButtonCallback(s_window, EventHandler::handleMouseButtonEvent);
    glfwSetWindowSizeCallback(s_window, EventHandler::handleWindowResizedEvent);
    glfwSetWindowCloseCallback(s_window, EventHandler::handleWindowClosedEvent);

Okay, then what? These 6 functions will be called whenever an event of their specific type occurs.
What should these functions do?
What should happen when a key is pressed, for example?
Well, we need a way for client applications to say what happens when a key is pressed.
Client applications need to be able to register a custom callback function to be called whenever a key is pressed.
Furthermore, we have more event types than just these 6 functions. We may have a couple of event types for each of these 6 functions.
For example, when ANY key event occurs this function
    handleKeyEvent()
will be called, but this may correspond either to a KeyPressedEvent or a KeyReleasedEvent.
So, client applications need to be able to register a custom callback function for each of OUR event types (8 in total).
For example, they need to be able to register a callback for when a key is pressed and another callback for when a key is released.
Let's add these 8 functions
    static inline void registerKeyPressedCallback(const KeyPressedCallback& callback) { s_keyPressedCallbacks.push_back(callback); }
    static inline void registerKeyReleasedCallback(const KeyReleasedCallback& callback) { s_keyReleasedCallbacks.push_back(callback); }
    static inline void registerMouseMovedCallback(const MouseMovedCallback& callback) { s_mouseMovedCallbacks.push_back(callback); }
    static inline void registerMouseScrolledCallback(const MouseScrolledCallback& callback) { s_mouseScrolledCallbacks.push_back(callback); }
    static inline void registerMouseButtonPressedCallback(const MouseButtonPressedCallback& callback) { s_mouseButtonPressedCallbacks.push_back(callback); }
    static inline void registerMouseButtonReleasedCallback(const MouseButtonReleasedCallback& callback) { s_mouseButtonReleasedCallbacks.push_back(callback); }
    static inline void registerWindowResizedCallback(const WindowResizedCallback& callback) { s_windowResizedCallbacks.push_back(callback); }
    static inline void registerWindowClosedCallback(const WindowClosedCallback& callback) { s_windowClosedCallbacks.push_back(callback); }
where
    typedef std::function<bool(KeyPressedEvent&)> KeyPressedCallback;
    typedef std::function<bool(KeyReleasedEvent&)> KeyReleasedCallback;
    typedef std::function<bool(MouseMovedEvent&)> MouseMovedCallback;
    typedef std::function<bool(MouseScrolledEvent&)> MouseScrolledCallback;
    typedef std::function<bool(MouseButtonPressedEvent&)> MouseButtonPressedCallback;
    typedef std::function<bool(MouseButtonReleasedEvent&)> MouseButtonReleasedCallback;
    typedef std::function<bool(WindowResizedEvent&)> WindowResizedCallback;
    typedef std::function<bool(WindowClosedEvent&)> WindowClosedCallback;
And what will these 8 functions do?
They will just add the given callback to a list of callbacks corresponding to the specific event type.
So we need 8 lists of callbacks, as members in EventHandler
    static std::vector<KeyPressedCallback> s_keyPressedCallbacks;
    static std::vector<KeyReleasedCallback> s_keyReleasedCallbacks;
    static std::vector<MouseMovedCallback> s_mouseMovedCallbacks;
    static std::vector<MouseScrolledCallback> s_mouseScrolledCallbacks;
    static std::vector<MouseButtonPressedCallback> s_mouseButtonPressedCallbacks;
    static std::vector<MouseButtonReleasedCallback> s_mouseButtonReleasedCallbacks;
    static std::vector<WindowResizedCallback> s_windowResizedCallbacks;
    static std::vector<WindowClosedCallback> s_windowClosedCallbacks;
and each of the register*() functions will just add the callback to the corresponding list, as shown above.
Then, once we have a list of callbacks, we can think about what the handle*() functions should do.
Well, they should call the callbacks.
But to do that, they need to first create an event.
For example, the handleMouseMovedEvent() function needs to construct a MouseMovedEvent, like that
    MouseMovedEvent event = { float(xPos), float(yPos) };
and then it can call the callbacks registered for MouseMovedEvents (the callbacks in s_mouseMovedCallbacks) like that
    for (const MouseMovedCallback& callback : s_mouseMovedCallbacks)
    {
        if (callback(event))
        {
            event.m_handled = true;
            break;
        }
    }
(The logic behind the if statement and setting m_handled is explained below, for now only notice that we're calling callback(event))
Constructing the event of the specific type will be different in the different handle*() functions,
but the for-loop for calling the callbacks will be exactly the same,
so we can create a template function for that
    template <typename EventT, typename CallbackT>
    static void handleEvent(EventT& event, const std::vector<CallbackT>& callbacks)
    {
        for (const CallbackT& callback : callbacks)
        {
            if (callback(event))
            {
                event.m_handled = true;
                break;
            }
        }
    }
Now the implementation of handleMouseMovedEvent() boils down to just this
    void EventHandler::handleMouseMovedEvent(GLFWwindow* window, double xPos, double yPos)
    {
        MouseMovedEvent event = { float(xPos), float(yPos) };
        handleEvent(event, s_mouseMovedCallbacks);
    }
Neat!
It's a bit more complicated in the handle*() functions that need to differentiate between multiple different event types.
For example handleKeyEvent() may construct either a KeyPressedEvent or a KeyReleasedEvent() depending on the value of the "action" parameter.
Those details are not important, and quite straightforward, so leaving it at that.

One final thing to explain here is why don't we just call
    callback(event)
in the handleEvent() template function.
Why do we do
    if (callback(event))
    {
        event.m_handled = true;
        break;
    }
All callbacks here return a bool which means whether the event was handled, or just skipped.
This might make more sense especially when considering multiple layers.
For example if we have a game where clicking the mouse makes the player jump,
this game world will be on one layer, but on top of that we may have another layer with GUI,
where clicking the mouse has another meaning.
So in that case we would have 2 callbacks registered in s_keyPressedCallbacks
and if one of them handles the event we want to NOT call the callback of the other layer.

That's about it. That's the event system.

Let's test it in Demo03.
Let's create callback functions for each event type, in Snake.cpp
    bool onKeyPressed(Pekan::KeyPressedEvent& event);
    bool onKeyReleased(Pekan::KeyReleasedEvent& event);
    bool onMouseMoved(Pekan::MouseMovedEvent& event);
    bool onMouseScrolled(Pekan::MouseScrolledEvent& event);
    bool onMouseButtonPressed(Pekan::MouseButtonPressedEvent& event);
    bool onMouseButtonReleased(Pekan::MouseButtonReleasedEvent& event);
    bool onWindowResized(Pekan::WindowResizedEvent& event);
    bool onWindowClosed(Pekan::WindowClosedEvent& event);
and let's implement them to just log the event using PekanLogger
    bool Snake::onKeyPressed(KeyPressedEvent& event)
    {
        PK_LOG_INFO(event, "Boris");
        return true;
    }
    ...
We need to register these callbacks using the EventHandler. We can do that in Snake's create() function, like that
    EventHandler::registerKeyPressedCallback(std::bind(&Snake::onKeyPressed, this, std::placeholders::_1));
    EventHandler::registerKeyReleasedCallback(std::bind(&Snake::onKeyReleased, this, std::placeholders::_1));
    EventHandler::registerMouseMovedCallback(std::bind(&Snake::onMouseMoved, this, std::placeholders::_1));
    EventHandler::registerMouseScrolledCallback(std::bind(&Snake::onMouseScrolled, this, std::placeholders::_1));
    EventHandler::registerMouseButtonPressedCallback(std::bind(&Snake::onMouseButtonPressed, this, std::placeholders::_1));
    EventHandler::registerMouseButtonReleasedCallback(std::bind(&Snake::onMouseButtonReleased, this, std::placeholders::_1));
    EventHandler::registerWindowResizedCallback(std::bind(&Snake::onWindowResized, this, std::placeholders::_1));
    EventHandler::registerWindowClosedCallback(std::bind(&Snake::onWindowClosed, this, std::placeholders::_1));
Okay, it works!
Pretty nice.

Final note, I copied only the event classes from Hazel Engine, the EventHandler was my own creation.

Event system done.
}

----------
07.04.2025
----------

{
Now that we have the event system, it'd be good to also allow applications to ask for the current state of things,
for example where the mouse is currently, or what the resolution is currently, or is a given key pressed at the moment.
I wouldn't call this a "part" of the event system, but it's definitely related, and more like a complementary feature.

So what we need basically, is something similar to these 4 temporary functions that we have right now in PekanEngine
    static bool isKeyPressed_W();
    static bool isKeyPressed_A();
    static bool isKeyPressed_S();
    static bool isKeyPressed_D();
I made those functions to allow the snake game (Demo03) to work before having the event system.
We need similar functions now, but done better, and covering everything that the event system covers.

Let's start with key events - KeyPressedEvent and KeyReleasedEvent.
We can cover those with 3 functions
    static bool isKeyPressed(int key);
    static bool isKeyReleased(int key);
    static bool isKeyRepeating(int key);
Next type of event to cover is MouseMovedEvent.
We can cover that with 1 function
    static glm::vec2 getMousePosition();
Next is MouseScrolledEvent - we will not cover that because it makes no sense to ask for the current mouse scroll
(and because GLFW doesn't support it)
Next is MouseButtonPressed and MouseButtonReleased. We need 2 functions
    static bool isMouseButtonPressed(bool leftOrRight);
    static bool isMouseButtonReleased(bool leftOrRight);
And I think the final one is WindowResizedEvent. We need 1 function
    static glm::ivec2 getWindowResolution();
That's it.
Done.
}

----------
11.04.2025
----------

{
Next feature to implement is layers.
I will use as reference this commit from Hazel Engine
    https://github.com/TheCherno/Hazel/commit/5bd809312a266c23d13d84dcd08a833a526aa264

Ended up not using much, I only copied and changed Layer and LayerStack,
everything else I had to do on my own.

I did the whole thing at once, without taking notes, so here's a sum up:
I'll divide it into 3 parts - layers, init/exit/update/render layers, events in layers.

1. First of all, a layer fundamentally is just something that can be initialized, exited, updated and rendered
    virtual bool init() { return true; }
    virtual void exit() {}
    virtual void update() {}
    virtual void render() {}
It also has a name but that's not important
    std::string m_name;
Then we have a LayerStack which is just a wrapper over a list of layers
    std::vector<Layer*> m_layers;
and it provides iterators for traversing the layer stack forwards and backwards
    std::vector<Layer*>::iterator begin() { return m_layers.begin(); }
    std::vector<Layer*>::iterator end() { return m_layers.end(); }
    std::vector<Layer*>::reverse_iterator rbegin() { return m_layers.rbegin(); }
    std::vector<Layer*>::reverse_iterator rend() { return m_layers.rend(); }
Nothing interesting there.
So how are we going to use layers in Pekan?
Well, scenes and GUI windows will be layers.
We actually don't need the class
    PekanScene
at all, because it's literally just a Layer without any extra functionality.
We still need the class
    PekanGUIWindow
because it has some ImGui-specific functionality in render(), but other than that we'll make it derive from Layer
    class PekanGUIWindow : public Layer

2. Okay, so scenes and GUI windows are layers.
Now what?
Well, currently in PekanApplication we have 2 members for a scene and a GUI window.
We don't want that. We want clients to be able to compose scenes and GUI windows as they wish,
maybe they want multiple scenes on top of each other, or they don't want a GUI window, or they want multiple GUI windows, etc.
So instead of having 2 members for a scene and a GUI window let's have a single LayerStack member
    LayerStack m_layerStack;
and then client applications can configure this stack as they wish in the _init() function, for example like that
    m_layerStack.pushLayer(demoScene);
    m_layerStack.pushLayer(demoGuiWindow);
(Notice that the order of adding the layers is important. Layers added first will be rendered first)
Then the only thing left to do is make PekanApplication work with this layer stack instead of a scene and a GUI window,
so in PekanApplication.cpp in all places where we previously did something with m_scene or m_guiWindow, (init/exit/update/render)
now we need to do it with all layers in the layer stack, like that for example:
    // Update all layers
    for (Layer* layer : m_layerStack)
    {
        if (layer)
        {
            layer->update();
        }
    }
    // Render all layers
    for (Layer* layer : m_layerStack)
    {
        if (layer)
        {
            layer->render();
        }
    }
And finally, we need to update our demos a bit, to configure the layer stack in their _init() functions.
That's it.
Now everything works same as before, but demos can configure layers freely.

3. Trickies part here is making events work with layers.
Currently we have a static class EventHandler and any code can register a callback for any type of event,
which is ok, but it gives too much freedom to clients.
We want to enforce the behavior of events being propagated through layers
in the opposite order of rendering, so that layers drawn last receive events first, because they are on top.
What we want is a way for each layer to specify its own way of handling a given type of event,
and then Pekan will automatically send events to layers in the correct order
and stop sending once a layer has successfully handled an event.
How can we do that?
Well, first we can have virtual functions for each type of event inside of class Layer
    virtual bool onKeyPressed(KeyPressedEvent& event) { return false; }
    virtual bool onKeyReleased(KeyReleasedEvent& event) { return false; }
    virtual bool onMouseMoved(MouseMovedEvent& event) { return false; }
    virtual bool onMouseScrolled(MouseScrolledEvent& event) { return false; }
    virtual bool onMouseButtonPressed(MouseButtonPressedEvent& event) { return false; }
    virtual bool onMouseButtonReleased(MouseButtonReleasedEvent& event) { return false; }
    virtual bool onWindowResized(WindowResizedEvent& event) { return false; }
    virtual bool onWindowClosed(WindowClosedEvent& event) { return false; }
so that derived classes can choose to override some of these functions if they want to react to a specific event.
Then we have to actually call those functions on each layer of the layer stack when an event occurs,
and we have to pass an Event object of the corresponding subtype.
How can we do that?
Well, we already have these 6 static functgions in EventHandler
    static void handleKeyEvent(GLFWwindow* window, int key, int scancode, int action, int mods);
    static void handleMouseMovedEvent(GLFWwindow* window, double xPos, double yPos);
    static void handleMouseScrolledEvent(GLFWwindow* window, double xOffset, double yOffset);
    static void handleMouseButtonEvent(GLFWwindow* window, int button, int action, int mods);
    static void handleWindowResizedEvent(GLFWwindow* window, int width, int height);
    static void handleWindowClosedEvent(GLFWwindow* window);
They are directly linked to GLFW by PekanEngine like that:
    glfwSetKeyCallback(s_window, EventHandler::handleKeyEvent);
    glfwSetCursorPosCallback(s_window, EventHandler::handleMouseMovedEvent);
    glfwSetScrollCallback(s_window, EventHandler::handleMouseScrolledEvent);
    glfwSetMouseButtonCallback(s_window, EventHandler::handleMouseButtonEvent);
    glfwSetWindowSizeCallback(s_window, EventHandler::handleWindowResizedEvent);
    glfwSetWindowCloseCallback(s_window, EventHandler::handleWindowClosedEvent);
They construct an Event object of a specific type and call the registered callbacks passing that Event object.
Now we still need to construct the Event objects in the exact same way,
but instead of calling the registered callbacks,
we will call the on*() functions on each layer of the layer stack.
Problem is we don't have access to the layer stack because this EventHandler is all static,
and the layer stack is part of an instance of PekanApplication,
so we'll need to move these handle*() functions to be member functions of PekanApplication
    void handleKeyEvent(int key, int scancode, int action, int mods);
    void handleMouseMovedEvent(double xPos, double yPos);
    void handleMouseScrolledEvent(double xOffset, double yOffset);
    void handleMouseButtonEvent(int button, int action, int mods);
    void handleWindowResizedEvent(int width, int height);
    void handleWindowClosedEvent();
removing the GLFWwindow pointer (we'll see why in a minute)
To implement them in PekanApplication we'll construct the Event objects in the exact same way,
but then instead of calling EventHandler's template function handleEvent()
which works with the registered callbacks,
we'll create a new template function
    static void _dispatchEvent(EventT& event, LayerStack& layerStack, bool (Layer::*onEventFunc)(EventT&))
that calls the on*() functions of each layer of the layer stack until the event is handled.
Then we just call that function with the constructed Event object and give it our application's layer stack
and a pointer to the specific on*() function that it needs to call on the layers. For example, like that:
    MouseMovedEvent event = { float(xPos), float(yPos) };
    _dispatchEvent(event, m_layerStack, &Layer::onMouseMoved);
That's it, that's what the handle*() functions do.
Now the only thing left to do is to connect those handle*() functions to GLFW
and actually make it so that they are called when an event occurs.
We cannot directly connect them to GLFW with the glfwSet*Callback() functions
because they require a callback which is a global/static function
(our handle*() functions are member functions of PekanApplication and so they contain an extra implicit "this" parameter)
What we can do is create yet another set of functions, but this time static in PekanEngine
    static void keyCallback(GLFWwindow* window, int key, int scancode, int action, int mods);
    static void mouseMovedCallback(GLFWwindow* window, double xPos, double yPos);
    static void mouseScrolledCallback(GLFWwindow* window, double xOffset, double yOffset);
    static void mouseButtonCallback(GLFWwindow* window, int button, int action, int mods);
    static void windowResizedCallback(GLFWwindow* window, int width, int height);
    static void windowClosedCallback(GLFWwindow* window);
Now these functions have the exact signature required by the glfwSet*Callback() functions
so we can directly register them to GLFW, like that
    glfwSetKeyCallback(s_window, keyCallback);
    glfwSetCursorPosCallback(s_window, mouseMovedCallback);
    glfwSetScrollCallback(s_window, mouseScrolledCallback);
    glfwSetMouseButtonCallback(s_window, mouseButtonCallback);
    glfwSetWindowSizeCallback(s_window, windowResizedCallback);
    glfwSetWindowCloseCallback(s_window, windowClosedCallback);
And now we reach the root of our problem.
How can we make these static functions call PekanApplication's handle*() functions that are very much non-static,
they are member functions and require a specific instance of a PekanApplication.
Well, we need a static instance of PekanApplication.
We need a mechanism in PekanEngine for a PekanApplication to be "registered"
and kept under a static member variable
    static PekanApplication* s_application;
For that we'll add this new function
    static void registerApplication(PekanApplication* application);
that every PekanApplication will need to call to "register" itself in PekanEngine
before it could be run.
And finally, having this static s_application, we can implement the callbacks as follows:
    void PekanEngine::keyCallback(GLFWwindow* window, int key, int scancode, int action, int mods)
    {
        if (s_application)
        {
            s_application->handleKeyEvent(key, scancode, action, mods);
        }
    }
    ...
That's it.
To sum up, for example looking at a mouse moved event:
Mouse moves -> GLFW calls PekanEngine::mouseMovedCallback()
-> it calls PekanApplication::handleMouseMovedEvent()
-> it constructs a MouseMovedEvent object and calls _dispatchEvent() with it
-> it calls Layer::onMouseMoved() on each layer of the layer stack until the event is handled
-> Layer::onMouseMoved() can be implemented by client to do whatever they want and return true if event is handled
   If not implemented, it will not do anything and just return false, meaning continue to next layer
}

----------
15.04.2025
----------

{
Next feature we'll implement from the list is a simple one:
    Create a way for applications to specify the window's title

Taking a quick look at our current architecture it makes the most sense
that we let applications have a name and then Pekan will automatically set window's title to be that name.
Each specific application will be able to set its name inside of the _init() method,
similar to how it configures the layer stack.
So, to do that, just add this member variable in PekanApplication
    std::string m_name;
and then we can set its value inside of Demo03_Application::_init() like that
    m_name = "Snake Game";
Same for the other demos as well.

Okay, now each application has a name.
We need to use that name for the window's title.
Window's title is set in PekanEngine.cpp like that
    s_window = glfwCreateWindow(width, height, DEFAULT_WINDOW_TITLE, nullptr, nullptr);
So instead of using the constant DEFAULT_WINDOW_TITLE we can use the registered application
    s_application
and use its name.
For that we'll need to have a getter for the name in PekanApplication
    const std::string& getName() const { return m_name; }

Hm but now there's a problem.
The function creating the window is
    PekanEngine::createWindow()
which is called by
    PekanEngine::init()
which is called in
    PekanApplication::init()
before registering the application, so when creating the window we don't yet know the name of our application.
How can we solve this?
We could separate engine initialization from window creation so that PekanApplication
can first initialize the engine, then register itself, and then use the engine to create a window.
But actually a better idea, at least at this point, seems to be merging registering with initialization,
so instead of having a separate function registerApplication() we can just add a parameter to
    PekanEngine::init()
which will be the application. Then init() will handle everything in the correct order.
Let's do that.

Okay, that solved the problem, but now there is another problem of similar nature.
We want to use the member PekanApplication::m_name when calling PekanEngine::init()
but this happens before calling PekanApplication::_init() so the specific application
has not set its name yet.
What we can do is to have a virtual getter for the name that should be implemented by specific applications
if they want to have a name.
So remove the member m_name and change getName() to be
    virtual std::string getName() const { return ""; }
Now in Demo03_Application instead of setting m_name = "Snake Game" inside of _init()
we can implement the getName() function, like that
    std::string getName() const override { return "Snake Game"; }
That's it. Now when PekanEngine calls
    s_application->getName();
this will call the overriden version of getName() and it will return "Snake Game".
If there is no overriden version of getName() then it will call the base version, PekanApplication's version,
which just returns an empty string, and the window's title will default to
    DEFAULT_WINDOW_TITLE

Okay, done.
Looks good. Every application has its name, and window's title corresponds to that name.
}
