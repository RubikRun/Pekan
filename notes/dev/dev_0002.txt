----------
05.02.2025
----------

{
Before starting to implement Pekan's architecture,
let's first add logging support.

...logging support, in progress...
}

----------
07.02.2025
----------

{
...logging support, in progress...
}

----------
08.02.2025
----------

{
Okay, logging support is ready.

====begin SUM UP OF LOGGING

--- There are 2 new files
        PekanLogger.h
        PekanLogger.cpp
    They contain logging functionality
    that can be used throughout Pekan Engine and Pekan Applications

--- To use PekanLogger, you just need to include header
        #include "PekanLogger.h"
    and then you can use these macros
        PK_LOG_ERROR(...)
        PK_LOG_WARNING(...)
        PK_LOG_INFO(...)
        PK_LOG_DEBUG(...)
    to log error messages, warning messages, info messages, or debug messages.
    Between the parentheses you can write anything, as if it's a standard C++ stream. For example
        PK_LOG_DEBUG("threadsCount = " << threadsCount);
        PK_LOG_ERROR("Failed to initialize version " << versionNumber << " of library.");
    would result in these messages being logged:
        [DEBUG]: threadsCount = 4
        [ERROR]: Failed to initialize version 4 of library.
    There are also these extended macros, that log the filename of the source file from where they're called
        PK_LOG_ERRORF(...)
        PK_LOG_WARNINGF(...)
        PK_LOG_INFOF(...)
        PK_LOG_DEBUGF(...)
    In order to use these extended macros, you need to define PK_FILENAME to be the name of your current source file.
    For example, if you want to use PekanLogger in source file
        main.cpp
    then you should do this
        #include "PekanLogger.h"
        #define PK_FILENAME "main.cpp"
    and then you can use the extended macros, like that
        PK_LOG_ERRORF("Failed to load OpenGL.");
    and it would result in this message being logged:
        [ERROR in main.cpp]: Failed to load OpenGL

--- In
        PekanLogger.h
    there are 6 macros
        PK_LOGGER_ERROR_SUPPORT
        PK_LOGGER_WARNING_SUPPORT
        PK_LOGGER_INFO_SUPPORT
        PK_LOGGER_DEBUG_SUPPORT
        PK_LOGGER_CONSOLE_SUPPORT
        PK_LOGGER_FILE_SUPPORT
    that can be set to either 0 or 1 to enable/disable support for
        - logging of different types of messages
        - logging to the console
        - logging to a file
    These 6 macros give compile-time control over the different functionalities.
    For example, if at any point we want to fully remove error logging from our code base,
    we can just toggle this macro to 0
        PK_LOGGER_ERROR_SUPPORT 0
    This might be important for performance later on.
    "Compile-time control" means that once we build Pekan Engine or a Pekan Application
    with a set of supported logging functionality,
    there is no way for user to enable a logging functionality that is not supported in this build.

--- If a given logging functionality is supported in a given build
    then user can enable/disable it with these environment variables
        PEKAN_LOGGER_ERROR_ENABLED
        PEKAN_LOGGER_WARNING_ENABLED
        PEKAN_LOGGER_INFO_ENABLED
        PEKAN_LOGGER_DEBUG_ENABLED
        PEKAN_LOGGER_CONSOLE_ENABLED
        PEKAN_LOGGER_FILE_ENABLED
    For example, if a build supports debug logging, meaning it's done with
        PK_LOGGER_DEBUG_SUPPORT 1
    then user can enable debug logging by setting
        set PEKAN_LOGGER_DEBUG_ENABLED=1
    or they can disable debug logging by setting
        set PEKAN_LOGGER_DEBUG_ENABLED=0

--- In
        PekanLogger.h
    there are 6 macros
        DEFAULT_PEKAN_LOGGER_ERROR_ENABLED
        DEFAULT_PEKAN_LOGGER_WARNING_ENABLED
        DEFAULT_PEKAN_LOGGER_INFO_ENABLED
        DEFAULT_PEKAN_LOGGER_DEBUG_ENABLED
        DEFAULT_PEKAN_LOGGER_CONSOLE_ENABLED
        DEFAULT_PEKAN_LOGGER_FILE_ENABLED
    that can be set to either 0 or 1 to enable/disable by default
        - logging of different types of messages
        - logging to the console
        - logging to a file
    These 6 macros determine whether a logging functionality should be enabled or disabled
    by default, if user has NOT specifically enabled/disabled it with an environment variable.

--- Logging to a file
    is the same as logging to the console
    but the messages are written to a log file.
    This log file is created in a directory that can be specified by user with this environment variable
        PEKAN_LOG_DIR
    If user hasn't specified a directory then OS's temporary directory will be used.
    The name of the log file is determined at startup,
    and it contains the current date-time so it's different each time you start Pekan Engine or a Pekan Application.
    For example, if user has set
        PEKAN_LOG_DIR=C:\dev\Pekan\build\.logs
    and they start Pekan Engine at 19:39:03 on 8th of February 2025
    then the filepath of the log file will be
        C:\dev\Pekan\build\.logs\pekan20250208193903.log

====end SUM UP OF LOGGING
}

{
Let's start implementing Pekan's architecture now.
First thing I'll do is create a class
    PekanEngine
in 2 new files
    PekanEngine.h
    PekanEngine.cpp
which will be similar to the one in Playground's SquaresScene.
The one in Playground's SquaresScene is a draft for the real PekanEngine
which I will write now.

... class PekanEngine, in progress ...

----------
10.02.2025
----------

... class PekanEngine, in progress ...

Okay, I have a class PekanEngine now, and it handles
- creating and destroying of graphics window
- creating and destroying of GUI window
- init and exit of all libraries

The demo in
    main.cpp
now uses PekanEngine for these things.

Next step is to make the engine handle the main loop.
Application should only provide implementation of init, update and render functions.

I'll start by creating a base class
    PekanScene
that will just contain pure virtual functions
    init()
    update()
    render()
    exit()
and another base class
    PekanGUIWindow
that will contain pure virtual functions
    init()
    render()

However, there is some functionality that will be common for all scenes
and some functionality that will be common for all GUI windows.
These are the common functionalities:
----
1. When calling a PekanScene's
    init()
function we want the caller to provide width and height of the scene,
and we want to save them to member variables in the scene.
2. When calling a PekanGUIWindow's
    init()
function we want the caller to provide a pointer to the GLFW window,
and we want to save that pointer to a member variable in the GUI window.
3. We want a PekanGUIWindow's
    render()
function to create a new ImGui frame,
then to draw ImGui elements, which is specific to the derived GUI window,
then to render ImGui draw data
----
We want all of these common functionalities to be handled in the base classes,
and provide a way for the specific parts to be implemented by derived classes.
The way I did it here is I added a private pure virtual function
    virtual bool _init() = 0;
in PekanScene, that should be implemented by derived classes
and it's called in the public function
    init()
after saving width and height to member variables.
Same way for PekanGUIWindow's init() function there is a private pure virtual function
    _init()
and same way for PekanGUIWindow's render() function there is a private pure virtual function
    _render()

----------
10.02.2025
----------

Today let's create a base class
    PekanApplication
which will handle logic common to all Pekan applications
(that is, applications made with Pekan)

Every PekanApplication should have an init() function
    bool init(GLFWwindow* window, int width, int height)
that takes in the GLFW window where application should be rendered,
and width and height of the application.
These 3 things are then saved to protected member variables
    GLFWwindow* window = nullptr;
    int width = -1;
    int height = -1;
so that derived classes can access those variables.

We will also need every PekanApplication to have a scene and a GUI window,
so we'll have 2 more protected member variables
    std::unique_ptr<PekanScene> scene;
    std::unique_ptr<PekanGUIWindow> guiWindow;
They are pointers to the base classes PekanScene and PekanGUIWindow.
Derived classes of PekanApplication will need to implement this pure virtual function
    virtual bool _init() = 0;
so that it sets up these 2 pointers to point to a specific scene and a specific GUI window
(instances of classes derived from PekanScene and PekanGUIWindow)

Finally, every PekanApplication can be run by calling this public function
    void run();
It runs the main loop and at every frame it updates and renders the scene and the GUI window.

I created a class
    DemoApplication
which is an example of a derived class of PekanApplication.
It is the same demo that we had before that.
The only thing that has to be done in this DemoApplication is to implement the
    _init()
function so that it sets up the 2 pointers
    scene
    guiWindow
to point to instances of DemoScene and DemoGUIWindow.

Okay, it works! And looks good.

}

----------
14.02.2025
----------

{
Next step is to separate engine code from demo code, in 2 projects.
So far, we have them separated in different source files.
Engine code is in
    PekanEngine.h
    PekanEngine.cpp
    PekanApplication.h
    PekanApplication.cpp
    PekanScene.h
    PekanScene.cpp
    PekanGUIWindow.h
    PekanGUIWindow.cpp
    PekanLogger.h
    PekanLogger.cpp
Demo code is in
    main.cpp
    DemoApplication.h
    DemoApplication.cpp
    DemoScene.h
    DemoScene.cpp
    DemoGUIWindow.h
    DemoGUIWindow.cpp

Let's separate them into 2 projects now - "Pekan" and "Demo".

I did it by moving Demo files from
    src/Pekan/Demo
into
    src/Demo
and creating a new CMake file in that directory which creates project Demo
and builds it as an executable, linking Pekan as a library.

For that to work we have to make project Pekan compile into a library,
and remove all demo files from there,
and add Demo subdirectory.

For now, in Demo we'll also have to link
    imgui
    glad
because we are still using raw OpenGL calls and raw ImGui code inside of the demo,
which will NOT be done like that in the future.
In the future we want to have OpenGL wrappers and ImGui wrappers that Pekan provides to all applications.

I also changed Demo classes to be under namespace Demo, instead of namespace Pekan.

Okay, done, looks okay, and it works.

}

----------
16.02.2025
----------

{
Now looking at the architecture of my classes, there is something odd.
The purpose of this file
    main.cpp
should be to initialize and run DemoApplication, nothing more.
However, currently it's also initializing and exiting PekanEngine, which is not good.
Engine initialization and exiting should be handled by PekanApplication.
So let's do that.

Actually, while I'm at it, PekanEngine should really be a singleton.
However, I don't like actally implementing singletons in C++ because there is no real need for that,
we can just make everything in PekanEngine be static, and this achieves the same as making a singleton class.
Let's first do that,
and then continue with moving engine initialization and exiting into PekanApplication.
}

{
Okay, at this point the basic engine architecture is implemented.
What remains to be done now is to create !wrappers!
of raw OpenGL and raw ImGui functions
Those wrappers will be provided by Pekan to its applications.
}

{
The first set of wrappers that I'm going to need are the OpenGL wrappers.
For that I will create a new project called
    PekanRenderer
and I'll change project Pekan to be called
    PekanCore

Let's start implementing OpenGL wrappers.
First, we'll need a
    VertexBuffer
class. This is probably the simplest OpenGL wrapper.
We only need create(), destroy(), bind() and undbind() functions. We need
    create()
to take in the raw vertex data and the size of that data
    void VertexBuffer::create(const void* data, long long size)
It will then generate a vertex buffer in OpenGL,
    glGenBuffers(1, &id);
save its ID to the member variable,
    unsigned id = 0;
bind this generated vertex buffer,
    glBindBuffer(GL_ARRAY_BUFFER, id);
and supply this vertex buffer with the given data
    glBufferData(GL_ARRAY_BUFFER, size, data, GL_STATIC_DRAW);

Then we can directly use this class VertexBuffer inside of DemoScene instead of raw OpenGL calls.
It works!

Next time think about loading OpenGL. Who should be responsible for that?
Currently PekanEngine does it, but maybe it'd be better that PekanRenderer does it.
Also, all OpenGL wrappers will need to check whether PekanRenderer is initialized before proceeding with their doings.
}

----------
17.02.2025
----------

{
A little thing that we can do for convenience is to make PekanApplication's destructor
call the exit() function so that client doesn't have to call it explicitly
if they know that their application will be destroyed.

Now I notice a little bug/mistake.
Inside PekanApplication we are calling
    scene->exit()
in the run() function.
It makes more sense to call it in the exit() function.
}

----------
18.02.2025
----------

{
The next OpenGL wrapper that I'm going to create
is actually an extention of the first one.

So far, VertexBuffer is only a buffer of raw data.
We need some way to specify it's layout.
In the same file
    VertexBuffer.h
we will create 2 new classes
    VertexBufferElement
    VertexBufferLayout
First one, VertexBufferElement, will represent a single buffer element, for example a Float4 element called "color", or a Mat4 element called "transform".
A buffer element usually corresponds to a vertex attribute inside a shader.

Side note:
We will keep the supported shader data types in an enum
    enum class ShaderDataType
    {
        None = 0, Float = 1, Float2 = 2, Float3 = 3, Float4 = 4, Mat3 = 5, Mat4 = 6, Int = 7, Int2 = 8, Int3 = 9, Int4 = 10, Bool = 11
    };
and we'll put this enum in a new file
    PekanRenderer.h
where we will also create a new class
    class PekanRenderer
that will contain static functions with common rendering functionality.
For now, we need only these 3 helper functions there related to this enum ShaderDataType
    static GLenum getShaderDataTypeOpenGLBaseType(ShaderDataType type);
    static unsigned getShaderDataTypeSize(ShaderDataType type);
    static unsigned getShaderDataTypeComponentsCount(ShaderDataType type);

Second one, VertexBufferLayout, will be just a list of buffer elements
with some extra functionality to calculate each element's offset and the total stride, which is info needed for OpenGL calls.

That's basically it, for now.

So far, our DemoScene creates a vertex buffer layout with only 1 element so it's not really a good test for our new classes.
Let's add 1 more element to the vertex buffer layout, and let that be color. Each vertex will have a color and we'll handle it in the shaders.
Okay, done.
Now each vertex is a different color and the color between them is interpolated.

Let's see if our classes VertexBufferElement and VertexBufferLayout will work if we use them in DemoScene.
Yep, they work.
Okay, considering them done now.
}

----------
20.02.2025
----------

{
Next OpenGL wrapper that I'm going to create is
    VertexArray

Currently nothing really connects a vertex buffer with its layout.
First of all, it'd be good to have a member variable inside VertexBuffer
    VertexBufferLayout layout;
which will be the layout assosiated with that buffer, and we'll let client pass that layout into the create() function.
That's good but vertex buffer is still not connected to its layout in OpenGL.

Currently client has the responsibility to configure vertex attributes (layout) in OpenGL,
based on the data in VertexBufferLayout, with these 2 calls
    glEnableVertexAttribArray(...)
    glVertexAttribPointer(...)
but the thing is OpenGL doesn't automatically connect this vertex attribute configuration (layout) to the vertex buffer.
It just makes this layout be the current state,
but then if we have another vertex buffer and bind it, OpenGL will still use that old layout.
We would have to configure vertex attributes with the layout of the second vertex buffer,
and this, once again, will just change the "layout state", and not really connect the vertex buffer with the layout.
So basically, every time we bind a vertex buffer we would have to configure its vertex attributes anew, which is terribly inconvenient.

We could do the vertex attribute configuration inside of the bind() function of VertexBuffer, but that's ineffective,
because it will configure vertex attributes each time when we bind a vertex buffer, as if it's configuring them for the first time.

Instead, we should use a vertex array, whose purpose is exactly that.
It's a collection of vertex buffers AND it maintains the layout state of each buffer,
so that when we bind a vertex buffer whose vertex attributes are already configured, that configuration is automatically applied.

So let's create a new class
    VertexArray
inside of 2 new files
    VertexArray.h
    VertexArray.cpp

This class will have all the standard stuff for an OpenGL object
    create(), destroy(), bind(), unbind(), id
and it will have a list of VertexBuffer's
    std::vector<VertexBuffer> vertexBuffers;
and a function for adding a new vertex buffer
    void addVertexBuffer(const VertexBuffer& vertexBuffer);

When adding a new vertex buffer, so inside addVertexBuffer(), we will configure the vertex attributes, like that
    const std::vector<VertexBufferElement>& layoutElements = layout.getElements();
    ...
    for (int i = 0; i < layoutElements.size(); ++i) {
        const VertexBufferElement& element = layoutElements[i];
        // For each element, enable and configure a vertex attribute
        glEnableVertexAttribArray(i);
        glVertexAttribPointer(
            i,
            element.getComponentsCount(),
            PekanRenderer::getShaderDataTypeOpenGLBaseType(element.type),
            element.normalized ? GL_TRUE : GL_FALSE,
            layout.getStride(),
            reinterpret_cast<GLvoid*>((long long)(element.getOffset()))
        );
    }
So now the 2 OpenGL calls are Pekan's responsibility, not client's.
And, more importantly, they are done on a bound vertex array, so the vertex array will remember that this layout belongs to this vertex buffer.

Now we can greatly simplify DemoScene's job around vertex array and vertex buffer
    vertexBuffer.create(vertices, sizeof(vertices), { { ShaderDataType::Float2, "position" }, { ShaderDataType::Float4, "color" } });
    vertexArray.create();
    vertexArray.addVertexBuffer(vertexBuffer);

It works!
}

----------
20.02.2025
----------

{
Before implementing the next OpenGL wrapper I'll have to setup a new external library
    glm
This time let's add it as a git submodule.
(I should've done this for all other libraries as well tbh, idk why I didn't, I'll do it some time in the future.)
    git submodule add https://github.com/g-truc/glm.git dep/glm

glm is a header-only library, but there is a CMake file that sets it up as such.
We could just add glm to our include directories but since there is a CMake file let's use that
    add_subdirectory(dep/glm)
Okay, done. Easy.
}

{
Oops, forgot to add glm project under "dep" folder.
Now that glm is a git submodule it doesn't make sense to just edit its CMake file and add this line to it
    set_target_properties(glm PROPERTIES FOLDER "dep")
What I should do instead is add this line to Pekan's root CMake file, where we add glm subdirectory.
Yep, that works.
Okay so if that works, then let's do it for all other libraries as well.
Putting the library inside "dep" shouldn't be the library's responsibility,
it should be the responsibility of whoever uses the library, in this case Pekan.
So after adding all subdirectories in CMakeLists.txt let's add all those libraries under "dep" folder, like that
    set_target_properties(glfw PROPERTIES FOLDER "dep")
    set_target_properties(glad PROPERTIES FOLDER "dep")
    set_target_properties(imgui PROPERTIES FOLDER "dep")
    set_target_properties(glm PROPERTIES FOLDER "dep")
It works! And it makes more sense that way.
}

{
Next OpenGL wrapper that I'm going to create is
    Shader

It needs to contain all stuff standard to an OpenGL object, so
    create(), destroy(), bind(), unbind(), isValid(), id

When client creates a shader we want them to provide source code for vertex shader and fragment shader, so we'll take these 2 parameters
    void Shader::create(const char* vertexShaderSource, const char* fragmentShaderSource);
What we need to do in create() function is to compile the 2 sub-shaders and link them into a single shader program.
Let's create a private member function for compiling a sub-shader, given its source code and its type
    unsigned compileShader(GLenum shaderType, const char* sourceCode);
Then we can use that function twice in create() to compile the vertex and the fragment shader
    const GLuint vertexShaderID = compileShader(GL_VERTEX_SHADER, vertexShaderSource);
    const GLuint fragmentShaderID = compileShader(GL_FRAGMENT_SHADER, fragmentShaderSource);
and then we can create the final shader program where we attach those 2 sub-shaders and link them
    id = glCreateProgram();
    glAttachShader(id, vertexShaderID);
    glAttachShader(id, fragmentShaderID);
    glLinkProgram(id);
At the end we can delete the sub-shaders because the final shader program contains them.
That's about it for create().

The other thing that client should be able to do with a shader is set uniform values inside the shader.
This might not be the best way to do it, but for now I'll just have a separate member function for each uniform type that we need to support,
and for now we will support only these 3:
    void setUniform1f(const char* uniformName, float value);
    void setUniform3fv(const char* uniformName, const glm::vec3& value);
    void setUniformMatrix4fv(const char* uniformName, const glm::mat4& value);
Later whenever we need a new uniform type we will just add a new member function.
This will not be the final solution, ultimately we should do something with templates/macros, but good enough for now.
Each of these functions needs to retrieve the location of the uniform with given name inside the shader,
and then set the given value to that uniform location.
Let's create a function for retrieving the uniform location for a given uniform name, because this is common to all uniform types.
    int getUniformLocation(const std::string& uniformName) const;
A little optimization that we can do here is we can cache uniform locations,
so that if client sets some uniform multiple times we don't retrieve it's location by an OpenGL call each time anew.
Instead we will retrieve the uniform location with an OpenGL call only the first time,
we will cache it,
and subsequent times we will just get the uniform location from cache.
The cache can be a simple std::unordered_map from string to int
    mutable std::unordered_map<std::string, int> uniformLocationCache;
That's it for uniforms.

----------
23.02.2025
----------

Shader class is basically ready now, let's test it by using it in DemoScene.
Okay, it works.
}

{
Before continuing, now is a good time to write a function that reads a text file into a string,
so that we can read shader's source code from file, instead of having it hardcoded.

Let's create 2 new files in PekanCore
    PekanUtils.h
    PekanUtils.cpp
for utility functions, not really related to the specifics of Pekan, just every-day useful functions.
We can add our new function for reading a text file there
    std::string readFileToString(const char* filePath);
and we can use that to read shader's source code from these 2 new files
    src/Demo/resources/vertex.shader
    src/Demo/resources/fragment.shader

In CMake I had to change Demo's working directory to be Demo's source directory. By default it's the build directory.
I needed to do this because in Demo's source code I want to be able to write filepaths to resources like that
    "resources/vertex.shader"
instead of
    "../../src/Demo/resources/vertex.shader"
or whatever the path is, if it was relative to the build directory.
}

{
Our current DemoScene doesn't really test uniforms because it doesn't have any uniforms.
Let's add a uniform to our vertex shader - a uniform for the square's position
    uniform vec2 uPosition;
Let's also add another component to GUI for controlling square's position
    ImVec2 position = ImVec2(0.0f, 0.0f);
Now all we need to do is set the value of uPosition uniform to the current value from GUI, and do this every frame, so inside
    DemoScene::update()
do this
    const ImVec2& position = guiWindow->getPosition();
    shader.setUniform2fv("uPosition", glm::vec2(position.x, position.y));
We will also have to bind the shader before doing this, because we specifically unbind it at the end of render().

Okay, it works.
Considering shaders done now.
}

{
Next OpenGL wrapper will be
    IndexBuffer
It's really simple because it's the same as VertexBuffer,
only difference is we're passing this to OpenGL calls
    GL_ELEMENT_ARRAY_BUFFER
instead of this
    GL_ARRAY_BUFFER
It could be argued that it's better to have a single Buffer class and let this buffer type be a parameter,
but for now, having only 2 types of buffers, I don't want to overcomplicate stuff so I'll leave it like that.

Let's try using IndexBuffer in DemoScene.
Okay, it works.
}

----------
24.02.2025
----------

{
Now looking at DemoScene, the only raw OpenGL calls left are
    glClearColor()
    glClear()
    glDrawElements()

Let's first create wrapper functions for the first 2 inside PekanRenderer
    static void clear();
    static void setBackgroundColor(const glm::vec4& backgroundColor);
and use them in DemoScene.
Done, it works.

Now create a similar wrapper function for glDrawElements()
    static void draw(unsigned elementsCount, DrawMode mode);
We don't need the last 2 parameters of glDrawElements() for now, so we will support only the first 2.
For the last 2 we'll just hardcode
    GL_UNSIGNED_INT, 0
meaning
    use GL_UNSIGNED_INT as indices type
and
    use 0 (nullptr) as indices data
so basically we don't use indices.
We have our indices in an IndexBuffer so we don't need these parameters. If we need them later we'll add them then.

I didn't want to use OpenGL enums for the draw mode because then client would have to pass OpenGL values and we want client to NOT use raw OpenGL.
So I had to create a Pekan enum DrawMode with the 12 different values corresponding to the 12 OpenGL enums that glDrawElements() supports.
For easy conversion between this Pekan enum and the OpenGL enum I added this function
    static unsigned getDrawModeOpenGLEnum(DrawMode drawMode);

Now the implementation of PekanRenderer's draw() function is just this
    glDrawElements(getDrawModeOpenGLEnum(mode), elementsCount, GL_UNSIGNED_INT, 0);

Let's see if it works in DemoScene.
Yep, it works.
}

{
We reached the point where we have OpenGL wrappers for everything used in DemoScene.
DemoScene doesn't make raw OpenGL calls anymore, instead it uses PekanRenderer's API.
To make sure let's remove glad dependecy from Demo project in CMake.
There were some tiny problems, glad.h was included in some PekanRenderer headers, where GLenum was used,
but I replaced GLenum with unsigned and moved the glad.h include into the source files.
It works now.
}

{
Now may be a good time to integrate the squares demo from playground branch
into our current v0.1 branch, and see if our OpenGL wrappers work well under more complicated circumstances.
We'll also see if we need any more OpenGL wrappers that might just not be required by our current DemoScene.

There are way more OpenGL wrappers that we will need in the future,
but the purpose now for v0.1 is to create a minimal working set of features,
and the condition that I set for myself in the beginning of v0.1 was
to be able to make the squares demo easily, without raw OpenGL calls.
(Also without raw ImGui calls but this will be the work for the next couple of days. Now let's finish OpenGL first)

I don't want to loose the current demo, I want to keep it around, so I'll rename its files to
    Demo00_Application.h
    Demo00_Application.cpp
    Demo00_Scene.h
    Demo00_Scene.cpp
    Demo00_GUIWindow.h
    Demo00_GUIWindow.cpp
and the new demo's files will be called
    Demo01_Application.h
    Demo01_Application.cpp
    Demo01_Scene.h
    Demo01_Scene.cpp
    Demo01_GUIWindow.h
    Demo01_GUIWindow.cpp

Okay, I integrated the squares demo as Demo01, it works now,
but I couldn't really use most of PekanRenderer's API.
In places where PekanRenderer's API doesn't support what needs to be done I used raw OpenGL calls,
so I brought back the glm dependency of Demo project.

There are a couple of problems, and it's good that in Demo01 I can see clearly what they are.
It's almost obvious how we need to extend the API.
}

{
So let's start extending PekanRenderer's API so that Demo01 doesn't need to do raw OpenGL calls.

Not in any particular order, the first thing that I see is
    glDrawArrays(GL_TRIANGLES, 0, vertices.size() / 2);
We already have a draw() function in PekanRenderer() but it does a call to
    glDrawElements()
I'll create a new function in PekanRenderer
    static void drawIndexed(unsigned elementsCount, DrawMode mode = DrawMode::Triangles);
that will do this same call to
    glDrawElements()
and the old function
    draw()
will do the new call to
    glDrawArrays()

}