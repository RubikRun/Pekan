----------
05.02.2025
----------

{
Before starting to implement Pekan's architecture,
let's first add logging support.

...logging support, in progress...
}

----------
07.02.2025
----------

{
...logging support, in progress...
}

----------
08.02.2025
----------

{
Okay, logging support is ready.

====begin SUM UP OF LOGGING

--- There are 2 new files
        PekanLogger.h
        PekanLogger.cpp
    They contain logging functionality
    that can be used throughout Pekan Engine and Pekan Applications

--- To use PekanLogger, you just need to include header
        #include "PekanLogger.h"
    and then you can use these macros
        PK_LOG_ERROR(...)
        PK_LOG_WARNING(...)
        PK_LOG_INFO(...)
        PK_LOG_DEBUG(...)
    to log error messages, warning messages, info messages, or debug messages.
    Between the parentheses you can write anything, as if it's a standard C++ stream. For example
        PK_LOG_DEBUG("threadsCount = " << threadsCount);
        PK_LOG_ERROR("Failed to initialize version " << versionNumber << " of library.");
    would result in these messages being logged:
        [DEBUG]: threadsCount = 4
        [ERROR]: Failed to initialize version 4 of library.
    There are also these extended macros, that log the filename of the source file from where they're called
        PK_LOG_ERRORF(...)
        PK_LOG_WARNINGF(...)
        PK_LOG_INFOF(...)
        PK_LOG_DEBUGF(...)
    In order to use these extended macros, you need to define PK_FILENAME to be the name of your current source file.
    For example, if you want to use PekanLogger in source file
        main.cpp
    then you should do this
        #include "PekanLogger.h"
        #define PK_FILENAME "main.cpp"
    and then you can use the extended macros, like that
        PK_LOG_ERRORF("Failed to load OpenGL.");
    and it would result in this message being logged:
        [ERROR in main.cpp]: Failed to load OpenGL

--- In
        PekanLogger.h
    there are 6 macros
        PK_LOGGER_ERROR_SUPPORT
        PK_LOGGER_WARNING_SUPPORT
        PK_LOGGER_INFO_SUPPORT
        PK_LOGGER_DEBUG_SUPPORT
        PK_LOGGER_CONSOLE_SUPPORT
        PK_LOGGER_FILE_SUPPORT
    that can be set to either 0 or 1 to enable/disable support for
        - logging of different types of messages
        - logging to the console
        - logging to a file
    These 6 macros give compile-time control over the different functionalities.
    For example, if at any point we want to fully remove error logging from our code base,
    we can just toggle this macro to 0
        PK_LOGGER_ERROR_SUPPORT 0
    This might be important for performance later on.
    "Compile-time control" means that once we build Pekan Engine or a Pekan Application
    with a set of supported logging functionality,
    there is no way for user to enable a logging functionality that is not supported in this build.

--- If a given logging functionality is supported in a given build
    then user can enable/disable it with these environment variables
        PEKAN_LOGGER_ERROR_ENABLED
        PEKAN_LOGGER_WARNING_ENABLED
        PEKAN_LOGGER_INFO_ENABLED
        PEKAN_LOGGER_DEBUG_ENABLED
        PEKAN_LOGGER_CONSOLE_ENABLED
        PEKAN_LOGGER_FILE_ENABLED
    For example, if a build supports debug logging, meaning it's done with
        PK_LOGGER_DEBUG_SUPPORT 1
    then user can enable debug logging by setting
        set PEKAN_LOGGER_DEBUG_ENABLED=1
    or they can disable debug logging by setting
        set PEKAN_LOGGER_DEBUG_ENABLED=0

--- In
        PekanLogger.h
    there are 6 macros
        DEFAULT_PEKAN_LOGGER_ERROR_ENABLED
        DEFAULT_PEKAN_LOGGER_WARNING_ENABLED
        DEFAULT_PEKAN_LOGGER_INFO_ENABLED
        DEFAULT_PEKAN_LOGGER_DEBUG_ENABLED
        DEFAULT_PEKAN_LOGGER_CONSOLE_ENABLED
        DEFAULT_PEKAN_LOGGER_FILE_ENABLED
    that can be set to either 0 or 1 to enable/disable by default
        - logging of different types of messages
        - logging to the console
        - logging to a file
    These 6 macros determine whether a logging functionality should be enabled or disabled
    by default, if user has NOT specifically enabled/disabled it with an environment variable.

--- Logging to a file
    is the same as logging to the console
    but the messages are written to a log file.
    This log file is created in a directory that can be specified by user with this environment variable
        PEKAN_LOG_DIR
    If user hasn't specified a directory then OS's temporary directory will be used.
    The name of the log file is determined at startup,
    and it contains the current date-time so it's different each time you start Pekan Engine or a Pekan Application.
    For example, if user has set
        PEKAN_LOG_DIR=C:\dev\Pekan\build\.logs
    and they start Pekan Engine at 19:39:03 on 8th of February 2025
    then the filepath of the log file will be
        C:\dev\Pekan\build\.logs\pekan20250208193903.log

====end SUM UP OF LOGGING
}

{
Let's start implementing Pekan's architecture now.
First thing I'll do is create a class
    PekanEngine
in 2 new files
    PekanEngine.h
    PekanEngine.cpp
which will be similar to the one in Playground's SquaresScene.
The one in Playground's SquaresScene is a draft for the real PekanEngine
which I will write now.

... class PekanEngine, in progress ...

----------
10.02.2025
----------

... class PekanEngine, in progress ...

Okay, I have a class PekanEngine now, and it handles
- creating and destroying of graphics window
- creating and destroying of GUI window
- init and exit of all libraries

The demo in
    main.cpp
now uses PekanEngine for these things.

Next step is to make the engine handle the main loop.
Application should only provide implementation of init, update and render functions.

I'll start by creating a base class
    PekanScene
that will just contain pure virtual functions
    init()
    update()
    render()
    exit()
and another base class
    PekanGUIWindow
that will contain pure virtual functions
    init()
    render()

However, there is some functionality that will be common for all scenes
and some functionality that will be common for all GUI windows.
These are the common functionalities:
----
1. When calling a PekanScene's
    init()
function we want the caller to provide width and height of the scene,
and we want to save them to member variables in the scene.
2. When calling a PekanGUIWindow's
    init()
function we want the caller to provide a pointer to the GLFW window,
and we want to save that pointer to a member variable in the GUI window.
3. We want a PekanGUIWindow's
    render()
function to create a new ImGui frame,
then to draw ImGui elements, which is specific to the derived GUI window,
then to render ImGui draw data
----
We want all of these common functionalities to be handled in the base classes,
and provide a way for the specific parts to be implemented by derived classes.
The way I did it here is I added a private pure virtual function
    virtual bool _init() = 0;
in PekanScene, that should be implemented by derived classes
and it's called in the public function
    init()
after saving width and height to member variables.
Same way for PekanGUIWindow's init() function there is a private pure virtual function
    _init()
and same way for PekanGUIWindow's render() function there is a private pure virtual function
    _render()

----------
10.02.2025
----------

Today let's create a base class
    PekanApplication
which will handle logic common to all Pekan applications
(that is, applications made with Pekan)

Every PekanApplication should have an init() function
    bool init(GLFWwindow* window, int width, int height)
that takes in the GLFW window where application should be rendered,
and width and height of the application.
These 3 things are then saved to protected member variables
    GLFWwindow* window = nullptr;
    int width = -1;
    int height = -1;
so that derived classes can access those variables.

We will also need every PekanApplication to have a scene and a GUI window,
so we'll have 2 more protected member variables
    std::unique_ptr<PekanScene> scene;
    std::unique_ptr<PekanGUIWindow> guiWindow;
They are pointers to the base classes PekanScene and PekanGUIWindow.
Derived classes of PekanApplication will need to implement this pure virtual function
    virtual bool _init() = 0;
so that it sets up these 2 pointers to point to a specific scene and a specific GUI window
(instances of classes derived from PekanScene and PekanGUIWindow)

Finally, every PekanApplication can be run by calling this public function
    void run();
It runs the main loop and at every frame it updates and renders the scene and the GUI window.

I created a class
    DemoApplication
which is an example of a derived class of PekanApplication.
It is the same demo that we had before that.
The only thing that has to be done in this DemoApplication is to implement the
    _init()
function so that it sets up the 2 pointers
    scene
    guiWindow
to point to instances of DemoScene and DemoGUIWindow.

Okay, it works! And looks good.

}

----------
14.02.2025
----------

{
Next step is to separate engine code from demo code, in 2 projects.
So far, we have them separated in different source files.
Engine code is in
    PekanEngine.h
    PekanEngine.cpp
    PekanApplication.h
    PekanApplication.cpp
    PekanScene.h
    PekanScene.cpp
    PekanGUIWindow.h
    PekanGUIWindow.cpp
    PekanLogger.h
    PekanLogger.cpp
Demo code is in
    main.cpp
    DemoApplication.h
    DemoApplication.cpp
    DemoScene.h
    DemoScene.cpp
    DemoGUIWindow.h
    DemoGUIWindow.cpp

Let's separate them into 2 projects now - "Pekan" and "Demo".

I did it by moving Demo files from
    src/Pekan/Demo
into
    src/Demo
and creating a new CMake file in that directory which creates project Demo
and builds it as an executable, linking Pekan as a library.

For that to work we have to make project Pekan compile into a library,
and remove all demo files from there,
and add Demo subdirectory.

For now, in Demo we'll also have to link
    imgui
    glad
because we are still using raw OpenGL calls and raw ImGui code inside of the demo,
which will NOT be done like that in the future.
In the future we want to have OpenGL wrappers and ImGui wrappers that Pekan provides to all applications.

I also changed Demo classes to be under namespace Demo, instead of namespace Pekan.

Okay, done, looks okay, and it works.

}