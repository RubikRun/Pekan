----------
05.02.2025
----------

{
Before starting to implement Pekan's architecture,
let's first add logging support.

...logging support, in progress...
}

----------
07.02.2025
----------

{
...logging support, in progress...
}

----------
08.02.2025
----------

{
Okay, logging support is ready.

====begin SUM UP OF LOGGING

--- There are 2 new files
        PekanLogger.h
        PekanLogger.cpp
    They contain logging functionality
    that can be used throughout Pekan Engine and Pekan Applications

--- To use PekanLogger, you just need to include header
        #include "PekanLogger.h"
    and then you can use these macros
        PK_LOG_ERROR(...)
        PK_LOG_WARNING(...)
        PK_LOG_INFO(...)
        PK_LOG_DEBUG(...)
    to log error messages, warning messages, info messages, or debug messages.
    Between the parentheses you can write anything, as if it's a standard C++ stream. For example
        PK_LOG_DEBUG("threadsCount = " << threadsCount);
        PK_LOG_ERROR("Failed to initialize version " << versionNumber << " of library.");
    would result in these messages being logged:
        [DEBUG]: threadsCount = 4
        [ERROR]: Failed to initialize version 4 of library.
    There are also these extended macros, that log the filename of the source file from where they're called
        PK_LOG_ERRORF(...)
        PK_LOG_WARNINGF(...)
        PK_LOG_INFOF(...)
        PK_LOG_DEBUGF(...)
    In order to use these extended macros, you need to define PK_FILENAME to be the name of your current source file.
    For example, if you want to use PekanLogger in source file
        main.cpp
    then you should do this
        #include "PekanLogger.h"
        #define PK_FILENAME "main.cpp"
    and then you can use the extended macros, like that
        PK_LOG_ERRORF("Failed to load OpenGL.");
    and it would result in this message being logged:
        [ERROR in main.cpp]: Failed to load OpenGL

--- In
        PekanLogger.h
    there are 6 macros
        PK_LOGGER_ERROR_SUPPORT
        PK_LOGGER_WARNING_SUPPORT
        PK_LOGGER_INFO_SUPPORT
        PK_LOGGER_DEBUG_SUPPORT
        PK_LOGGER_CONSOLE_SUPPORT
        PK_LOGGER_FILE_SUPPORT
    that can be set to either 0 or 1 to enable/disable support for
        - logging of different types of messages
        - logging to the console
        - logging to a file
    These 6 macros give compile-time control over the different functionalities.
    For example, if at any point we want to fully remove error logging from our code base,
    we can just toggle this macro to 0
        PK_LOGGER_ERROR_SUPPORT 0
    This might be important for performance later on.
    "Compile-time control" means that once we build Pekan Engine or a Pekan Application
    with a set of supported logging functionality,
    there is no way for user to enable a logging functionality that is not supported in this build.

--- If a given logging functionality is supported in a given build
    then user can enable/disable it with these environment variables
        PEKAN_LOGGER_ERROR_ENABLED
        PEKAN_LOGGER_WARNING_ENABLED
        PEKAN_LOGGER_INFO_ENABLED
        PEKAN_LOGGER_DEBUG_ENABLED
        PEKAN_LOGGER_CONSOLE_ENABLED
        PEKAN_LOGGER_FILE_ENABLED
    For example, if a build supports debug logging, meaning it's done with
        PK_LOGGER_DEBUG_SUPPORT 1
    then user can enable debug logging by setting
        set PEKAN_LOGGER_DEBUG_ENABLED=1
    or they can disable debug logging by setting
        set PEKAN_LOGGER_DEBUG_ENABLED=0

--- In
        PekanLogger.h
    there are 6 macros
        DEFAULT_PEKAN_LOGGER_ERROR_ENABLED
        DEFAULT_PEKAN_LOGGER_WARNING_ENABLED
        DEFAULT_PEKAN_LOGGER_INFO_ENABLED
        DEFAULT_PEKAN_LOGGER_DEBUG_ENABLED
        DEFAULT_PEKAN_LOGGER_CONSOLE_ENABLED
        DEFAULT_PEKAN_LOGGER_FILE_ENABLED
    that can be set to either 0 or 1 to enable/disable by default
        - logging of different types of messages
        - logging to the console
        - logging to a file
    These 6 macros determine whether a logging functionality should be enabled or disabled
    by default, if user has NOT specifically enabled/disabled it with an environment variable.

--- Logging to a file
    is the same as logging to the console
    but the messages are written to a log file.
    This log file is created in a directory that can be specified by user with this environment variable
        PEKAN_LOG_DIR
    If user hasn't specified a directory then OS's temporary directory will be used.
    The name of the log file is determined at startup,
    and it contains the current date-time so it's different each time you start Pekan Engine or a Pekan Application.
    For example, if user has set
        PEKAN_LOG_DIR=C:\dev\Pekan\build\.logs
    and they start Pekan Engine at 19:39:03 on 8th of February 2025
    then the filepath of the log file will be
        C:\dev\Pekan\build\.logs\pekan20250208193903.log

====end SUM UP OF LOGGING
}

{
Let's start implementing Pekan's architecture now.
First thing I'll do is create a class
    PekanEngine
in 2 new files
    PekanEngine.h
    PekanEngine.cpp
which will be similar to the one in Playground's SquaresScene.
The one in Playground's SquaresScene is a draft for the real PekanEngine
which I will write now.

... class PekanEngine, in progress ...

----------
10.02.2025
----------

... class PekanEngine, in progress ...

Okay, I have a class PekanEngine now, and it handles
- creating and destroying of graphics window
- creating and destroying of GUI window
- init and exit of all libraries

The demo in
    main.cpp
now uses PekanEngine for these things.

Next step is to make the engine handle the main loop.
Application should only provide implementation of init, update and render functions.

I'll start by creating a base class
    PekanScene
that will just contain pure virtual functions
    init()
    update()
    render()
    exit()
and another base class
    PekanGUIWindow
that will contain pure virtual functions
    init()
    render()

However, there is some functionality that will be common for all scenes
and some functionality that will be common for all GUI windows.
These are the common functionalities:
----
1. When calling a PekanScene's
    init()
function we want the caller to provide width and height of the scene,
and we want to save them to member variables in the scene.
2. When calling a PekanGUIWindow's
    init()
function we want the caller to provide a pointer to the GLFW window,
and we want to save that pointer to a member variable in the GUI window.
3. We want a PekanGUIWindow's
    render()
function to create a new ImGui frame,
then to draw ImGui elements, which is specific to the derived GUI window,
then to render ImGui draw data
----
We want all of these common functionalities to be handled in the base classes,
and provide a way for the specific parts to be implemented by derived classes.
The way I did it here is I added a private pure virtual function
    virtual bool _init() = 0;
in PekanScene, that should be implemented by derived classes
and it's called in the public function
    init()
after saving width and height to member variables.
Same way for PekanGUIWindow's init() function there is a private pure virtual function
    _init()
and same way for PekanGUIWindow's render() function there is a private pure virtual function
    _render()

}