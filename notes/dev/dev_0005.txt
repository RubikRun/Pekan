----------
23.08.2025
----------

Started developing the game
    Gleam House
with Pekan, in a separate repository.

----------
24.08.2025
----------

{
Found a bug in Pekan.
While rendering a grid with a checkered pattern I noticed this weird bug.
If the grid is sufficiently big (81x81 or bigger),
then the second RectangleShape being rendered
takes the color of the first RectangleShape being rendered.

Why?
The problem is this shader of Pekan:
    2D_Batch_1DTexture_FragmentShader.pkshad
Specifically, this line
    vec4 shapeColor = texture(uColorsTexture, (vShapeIndex) / float(uColorsCount - 1));
It samples the texture very close to the borders of the texels,
and for bigger values of uColorsCount, the sampled texture coordinates become too small
and maybe a floating point precision error happens?
For example, if we have
    uColorsCount = 5001
and
    vShapeIndex = 1
then this expression
    (vShapeIndex) / float(uColorsCount - 1)
evaluates to
    0.0002
However, a texel's size in this texture is
    1 / 5001 = 0.00019996
So this value 0.0002 is almost on the border between texel 0 and texel 1.
We know that since vShapeIndex is 1, we need it to sample from texel 1,
so ideally it would sample at
    (1 / 5001) + (1 / 5001) / 2
which is the center of texel 1.
So, basically we need to change this line
    vec4 shapeColor = texture(uColorsTexture, (vShapeIndex) / float(uColorsCount - 1));
to be
    vec4 shapeColor = texture(uColorsTexture, (vShapeIndex + 0.5) / float(uColorsCount));
instead.
That's it. Now it works.

All demos work as well.

Done.
}

{
Found a feature missing in Pekan and I need it for Gleam House.
We need support for custom texture coordinates for the 4 corners of our Sprite class.
Right now we always assign texture coordinates from [0, 1] to our Sprite's rectangle geometry.
We want to allow client code to determine this range.

Let's have these member variables
    glm::vec2 m_textureCoordinatesMin = { 0.0f, 0.0f };
    glm::vec2 m_textureCoordinatesMax = { 1.0f, 1.0f };
that will determine the rectangle in texture space that the sprite will map to,
instead of always mapping to the rectangle [0, 0] to [1, 1].
Then, we'll have getters and setters for them, of course.
And, most importantly, we'll use them in Sprite's
    updateVerticesWorld()
function when we set "textureCoordinates" attribute of the 4 vertices
    m_verticesWorld[0].textureCoordinates = { m_textureCoordinatesMin.x, m_textureCoordinatesMin.y };
    m_verticesWorld[1].textureCoordinates = { m_textureCoordinatesMax.x, m_textureCoordinatesMin.y };
    m_verticesWorld[2].textureCoordinates = { m_textureCoordinatesMax.x, m_textureCoordinatesMax.y };
    m_verticesWorld[3].textureCoordinates = { m_textureCoordinatesMin.x, m_textureCoordinatesMax.y };
That's it.
}

----------
31.08.2025
----------

{
To continue Gleam House's development we need a new feature in Pekan.
We need support for post-processing shaders.

For that, we'll basically have to do our rendering to a FrameBuffer object
instead of directly to the window.
This FrameBuffer object will be linked to a 2D texture
that we can then render on top of 2 triangles covering the whole window,
using a custom fragment shader, which will be the "post-processing shader".

Okay, did it.
Here's what I did:
1. Created a new class
        class FrameBuffer
    in 2 new files
        FrameBuffer.h
        FrameBuffer.cpp
    It can be created with some width and height:
        void create(int width, int height);
    It has standard destroy(), bind(), unbind() and isValid() functions.
    Internally it consists of a 2D texture and a render buffer
        Texture2D m_texture;
		RenderBuffer m_renderBuffer;
    The 2D texture will contain the color channels of rendered pixel
    and the render buffer will contain the depth and stencil channels of rendered pixels.
    What is a RenderBuffer? See in next point.
    The m_texture and m_renderBuffer are created in these 2 functions
        void createTexture(int width, int height);
		void createRenderBuffer(int width, int height);
    which are called from create(...)
    In createTexture() we create m_texture as a standard 2D texture with the same width and height as the frame buffer,
    (however we only allocate memory for it, we don't put any data, see point 3)
    and at the end we attach the texture to the frame buffer like that:
        m_texture.attachToFrameBuffer(*this);
    This attachToFrameBuffer() is a new function in class Textutre2D
        void attachToFrameBuffer(const FrameBuffer& frameBuffer) const;
    It basically needs to do this OpenGL call:
        GLCall(glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, m_id, 0));
    Similarly in createRenderBuffer() we need to create a RenderBuffer with the same width and height and attach it to the frame buffer:
        m_renderBuffer.attachToFrameBuffer(*this);
    We'll see this attachToFrameBuffer() function of class RenderBuffer below when looking at class RenderBuffer
    Finally, we have this function
        void bindTexture() const;
    which just binds the underlying texture
        m_texture.bind();
    We need this because binding the FrameBuffer and binding its texture are conceptually different,
    and users of this class WILL need to bind the texture separately.
    Also, in bind() we don't bind m_texture and we don't bind m_renderBuffer, we only bind the frame buffer.
2. Created a new class
        class RenderBuffer
    in 2 new files
        RenderBuffer.h
        RenderBuffer.cpp
    It can be created with some width and height:
        void create(int width, int height);
    It has standard destroy(), bind(), unbind() and isValid() functions.
    In the create() function, after creating the render buffer object, we need to declare its storage:
        GLCall(glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, width, height));
    For now, we'll hardcode it to be 24 depth bits and 8 stencil bits. Later we might abstract this away into the API.
    We need one more things, which is this function
        void attachToFrameBuffer(const FrameBuffer& frameBuffer) const;
    for attaching the render buffer to a frame buffer. It just needs to do this OpenGL call:
        glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, m_id);
3. We need to add a function to Texture2D
        void setSize(int width, int height, int numChannels = 4);
    that just sets the size of the texture, allocates that much memory, but doesn't set any data.
    We need this in FrameBuffer's createTexture() function to create the texture but leave its data empty.
    The data will automatically get filled because the texture is attached to the frame buffer,
    so whenever the frame buffer is bound and a draw call happens some pixel data will get filled to the texture.
4. Created a new class
        class PostProcessor
    in 2 new files
        PostProcessor.h
        PostProcessor.cpp
    The idea of this class is to tie together a FrameBuffer with a rectangle covering the whole window
    where the final texture will be rendered with the post-processing shader applied.
    Also, it will expose the API through which client code can use post-processing.
    So, it will be a singleton/static class and it will have these 3 public functions
        static bool init(const char* postProcessingShaderFilepath);
        static void beginFrame();
        static void endFrame();
    Client code will need to initialize the PostProcessor if they want to use it,
    and that's when they will provide the post-processing shader that they want to use.
    Then, in scene's render() function client code will have to call
        PostProcessor::beginFrame();
        PostProcessor::endFrame();
    if they want post-processing on that frame.
    Internally, in the .cpp file we'll have a single global instance of a FrameBuffer
        static FrameBuffer g_frameBuffer;
    We will also have a single global instance of a RenderObject
        static RenderObject g_renderObject;
    This RenderObject will be the rectangle covering the whole window,
    where g_frameBuffer's texture will be drawn and the post-processing shader will be applied.
    In PostProcessor's init() function we need to create the FrameBuffer with window's size
        const glm::ivec2 windowSize = PekanEngine::getWindow().getSize();
        g_frameBuffer.create(windowSize.x, windowSize.y);
    and then create g_renderObject as well - it's mostly straightforward, so skipping some details here,
    but the important part is that it's a rectangle covering the whole window and it has the post-processing shader.
    In PostProcessor's beginFrame() function we need to bind the frame buffer
        g_frameBuffer.bind();
    because we want any subsequent draw calls to go on this frame buffer, NOT directly on the screen.
    Then, in PostProcessor's endFrame() function we need to unbind the frame buffer
        g_frameBuffer.unbind();
    because it already contains the full rendered frame, we don't want to draw to it anymore,
    instead we want to draw to the screen now. Unbinding a frame buffer binds the default frame buffer which is the screen.
    After that we will bind frame buffer's texture which contains the rendered frame, but without post-processing yet
        g_frameBuffer.bindTexture();
    and we will render g_renderObject
        g_renderObject.render();
    which will render, on screen, the contents of the texture, which is the rendered frame, but with the post-processing shader applied.
That's it.
It almost works now.

----------
02.09.2025
----------

One last thing that we need in our post-processing is support for MSAA.
Currently when we enable MSAA in our scene (Demo06_Scene for example)
it is enabled only for the default frame buffer, which is the viewport,
however we are rendering our shapes to a separate FrameBuffer and so they are not anti-aliased.
Then, when we draw this separate FrameBuffer onto the viewport using a 2D texture
we get anti-aliasing but it's of no use because the actual shapes are already drawn on the texture.

Here's what I did to add support for MSAA in post-processing:
1. Created a new class
        Texture2DMultisample
    which is similar to Texture2D but with multiple samples per texel.
    Also it doesn't need most of the functionality of Texture2D, more specifically I removed these functions:
        setMinifyFunction, setMagnifyFunction, setWrapModeX, setWrapModeY, setBorderColor, setImage
    and the overload of create() taking in an Image.
    Then, we need this new member variable
        int m_samplesPerTexel = -1;
    that will be taken in in create()
        void create(int samplesPerTexel);
    Finally, we use
        GL_TEXTURE_2D_MULTISAMPLE
    everywhere instead of GL_TEXTURE_2D
    and in setSize() we call
        glTexImage2DMultisample(...)
    instead of glTexImage2D().
    That's about it.
2. Extend class RenderBuffer to support multiple samples.
    Add an int "samplesPerPixel" parameter to the create() function
        void create(int width, int height, int samplesPerPixel = 1);
    Then, in create() check if samplesPerPixel > 1, and if so we'll call
        glRenderbufferStorageMultisample(...)
    Otherwise we'll call
        glRenderbufferStorage(...)
    as we did until now.
    We don't need to keep this "samplesPerPixel" value in a member variable
    because we use it only once in the create() function.
    If we need it later, we'll add a member variable.
3. Extend class FrameBuffer to support multiple samples.
    Add an int "samplesPerPixel" parameter to the create() function
        void create(int width, int height, int samplesPerPixel = 1);
    together with a member variable
        int m_samplesPerPixel = -1;
    Add a new member variable
        Texture2DMultisample m_textureMultisample;
    We will use either m_texture or m_textureMultisample depending on the value of m_samplesPerPixel
    Add a new function
        void createTextureMultisample(int width, int height);
    for creating a multisample texture instead of a normal one.
    Then in create() call either createTexture() or createTextureMultisample()
    depending on the value of m_samplesPerPixel.
    Similarly in bindTexture() and destroy() use the correct texture depending on the value of m_samplesPerPixel
    Then, in
        createRenderBuffer()
    pass m_samplesPerPixel when calling m_renderBuffer's create() function:
        m_renderBuffer.create(width, height, m_samplesPerPixel);
    Finally we need this function
        void resolveMultisampleToSinglesample(FrameBuffer& targetFrameBuffer);
    that copies a multisample FrameBuffer into a single-sample one.
4. Extend class PostProcessor to support multiple samples.
    Add an int "samplesPerPixel" parameter to the init() function
        static bool init(const char* postProcessingShaderFilepath, int samplesPerPixel);
    together with a global static variable in the .cpp file
        static int g_samplesPerPixel = -1;
    Then, we'll have 2 FrameBuffers instead of one, again as global static variables
        static FrameBuffer g_frameBufferMultisample;
        static FrameBuffer g_frameBufferFinal;
    In the case of doing multisample rendering the draw calls will draw into g_frameBufferMultisample
    and in the end in endFrame() we will copy all pixel data from g_frameBufferMultisample to g_frameBufferFinal
    transforming the data from multisample to single-sample (we'll use the resolveMultisampleToSinglesample() function described above)
    In the case of doing single-sample rendering the draw calls will go directly into g_frameBufferFinal.
That's about it.

It works!

Noticed a small bug.
It looks like something is wrong with depth testing in Demo06.
The center square appears to be behind all other shapes, although it's rendered last.
This is definitely caused by the PostProcessor who enables depth testing in beginFrame().
We don't want depth testing in Demo06.
We want the depth testing enabled state to remain the same, whatever client code has set.
So, let's not touch depth testing in beginFrame().
However, we still need depth testing disabled in endFrame() when rendering the rectangle.
Let's disable it but then bring it back to its original state.
We'll disable it only if it's not already disabled by client code
    bool originalIsEnabledDepthTest = RenderState::isEnabledDepthTest();
    if (originalIsEnabledDepthTest)
    {
        RenderState::disableDepthTest();
    }
and then after rendering the rectangle we'll enable it back if needed
    if (originalIsEnabledDepthTest)
    {
        RenderState::enableDepthTest();
    }
That's it.
It works now.
Center square in Demo06 is correctly drawn on top of all other shapes.

Done.
}

----------
03.09.2025
----------

{
While we're at it, let's test post-processing shaders.
Let's add 5 different post-processing shaders in Demo06
and a combo box in GUI to choose between them.

Done. Works pretty good and looks cool.
}

----------
09.09.2025
----------

{
While working on Gleam House I found a very sneaky bug.
If you create a texture in the init() function of Gleam House's scene,
but after initializing PostProcessor,
you get black screen.
Why?
Still not fully sure, but it has something to do with the fact that
creating a texture binds it to the currently active slot,
and the fact that
in PostProcessor we expect frame buffer's texture to be bound on slot 0,
because that's where shader expects it to be.
So, when we create a texture like that we probably bind it to slot 0.
This unbinds the frame buffer's texture from slot 0 and leaves our random texture bound there instead.
Then, in PostProcessor's beginFrame() and endFrame() function it expects that slot 0
will contain frame buffer's texture, but nope, it contains our random texture.

Solution is simple.
In PostProcessor's endFrame() function we need to explicitly bind frame buffer's texture to slot 0,
not just "bind wherever".
We need to do this:
    g_frameBufferFinal.bindTexture(0);
instead of just
    g_frameBufferFinal.bindTexture();
Of course, we don't have a bindTexture() overload that takes in a slot, but we can easily add it.
It just needs to pass the given slot to the underlying texture's bind() function, like this:
    m_textureMultisample.bind(slot);
or
    m_texture.bind(slot);
That's it.

It works now.
Done.
}

----------
21.09.2025
----------

{
To continue work on Gleam House
we need to add support for composing Transformable2D objects in parent-child hierarchies.
The idea is fundamentally very simple.
Each Transformable2D object can have a parent which is another Transformable2D object.
A child will always be transformed relative to its parent.

Until now each object had position, rotation and scale,
that together formed a 3x3 matrix that can transform 2D points from local space to world space.
Now we'll need to consider parent's transform as well.
Let's define 2 terms:
- An object's "world matrix":
    A 3x3 matrix that transforms 2D points from an object's local space to world space
- An object's "local matrix":
    A 3x3 matrix that transforms 2D points from an object's local space to parent's local space
    (or to world space, if there is no parent)
While we're at it, let's also define:
- An object's "local space":
    A coordinate system relative to the object itself.
    Used for defining the object.
- "world space":
    The coordinate system for the entire scene.
    Used for determining where objects actually appear when rendered.
With these definitions in mind,
we already know how to calculate an object's local matrix - we just use its position, rotation and scale.
That's what we've been doing so far,
we just didn't call it a local matrix because we didn't need a distinction between a local matrix and a world matrix.
Question now is how to calculate an object's world matrix?
We'll define it recursively:
    Let P be parent's world matrix.
    Let L be child's local matrix.
    Then child's world matrix is:
        P * L
    If there is no parent, child's world matrix is:
        L
That's it.
In other words, to transform a 2D point from an object's local space to world space
we need to multiply it first by object's local matrix, then by parent's local matrix,
then by parent's parent's local matrix, etc... until there is no parent.

How will we implement this?
First, we need a parent pointer as a member variable in class Transformable2D:
    const Transformable2D* m_parent = nullptr;
together with a setter
    void setParent(const Transformable2D* parent);
that needs to do just this:
    m_parent = parent;
Then we will need to rename the function
    const glm::mat3& getTransformMatrix() const;
to be
    const glm::mat3& getLocalMatrix() const;
and add a new function:
    const glm::mat3& getWorldMatrix() const;
Implementing it is quite simple, given the recursive definition above:
    const glm::mat3& localMatrix = getLocalMatrix();
    if (m_parent != nullptr)
    {
        const glm::mat3& parentWorldMatrix = m_parent->getWorldMatrix();
        const glm::mat3 worldMatrix = parentWorldMatrix * localMatrix;
        return worldMatrix;
    }
    return localMatrix;
Finally, in all places that call getTransformMatrix()
we need to call getWorldMatrix() instead.
That's about it.
It works now.

Optimization time!
It works fine like that, but it can become quite slow if have big hierarchies.
Why?
Because if an object has N levels of parents,
then calling getWorldMatrix() on it will do N recursive calls
and N matrix multiplications.
In a real scene this will almost always be wasteful.
What can we do?
We can cache the world matrix, in a similar way to how we cache the local matrix in
    mutable glm::mat3 m_transformMatrix = glm::mat3(1.0f);
Let's rename this cached matrix to
    mutable glm::mat3 m_localMatrix = glm::mat3(1.0f);
and add a new cached matrix:
    mutable glm::mat3 m_worldMatrix = glm::mat3(1.0f);
Also, let's rename this flag
    mutable bool m_needUpdateTransformMatrix = false;
that is related to the cached local matrix to
    mutable bool m_isDirtyLocalMatrix = true;
and add a new flag
    mutable bool m_isDirtyWorldMatrix = true;
So far, whenever we change position, rotation or scale,
we mark local matrix as dirty by setting the flag to true:
    m_isDirtyLocalMatrix = true;
Now in all of these cases we also want to mark the world matrix as dirty:
    m_isDirtyWorldMatrix = true;
because a local change definitely means a world change as well.
Are there other cases where we need to mark the world matrix dirty?
Yes, definitely.
One of them is setParent() - whenever a new parent is set we definitely want to recalculate the world matrix when requested.
Another, more subtle one, is when parent's world matrix changes.
How do we know when parent's world matrix changes?
That's a bit tricky.
We can make the parent inform all of its children when a change occurs,
but this will require having a list of children pointers in each Transformable2D object
which is not ideal, I want to keep Transformable2D lightweight.
Without the parent knowing about its own children, there is no way for parent to inform them when a change occurs.
So, instead it will be child's responsibility to ask if parent has changed.
At what point should it ask that?
When asked for the world matrix.
So far in getWorldMatrix() we update the world matrix only if the dirty flag is on:
    if (m_isDirtyWorldMatrix)
    {
        updateWorldMatrix();
    }
but now we'll also need to check if parent has changed since the last world matrix calculation.
How exactly can we do that?
We could cache parent's world matrix in updateWorldMatrix()
and then in getWorldMatrix() we can ask for parent's world matrix again and compare with our cached one,
but this would defeat the purpose of this whole optimization,
because we'll still need to do N recursive calls for this, and N matrix comparisons,
so basically back to square one.
Is there a better way?
Yes! We will introduce the concept of a "change ID".
Each Transformable2D object will have a change ID
which will uniquely encapsulate the current state of the transformable object,
including the state of the parent.
This change ID will be just a number
with the special property that it changes whenever something in the object changes.
    --begin SIDE NOTE
    By the way, we also need this change ID for something else.
    We need it in class Sprite and class Shape because they are doing a dirty flag optimization
    on their vertices and they want to know when the underlying Transformable2D object changes.
    So far we did this with this callback:
        virtual void onTransformChanged() {}
    but we will no longer be able to do that because now this callback would have to be called
    when parent changes as well, which we can't do since parent doesn't know about its children.
    Instead of this callback, class Sprite and class Shape will cache the change ID, then later ask for current change ID
    and compare with the cached one, to know if they need to recalculate vertices.
    --end SIDE NOTE
So let's implement this change ID. Add a new member
    mutable unsigned m_changeId = 0;
together with a getter
    unsigned getChangeId() const;
Whenever position, rotation or scale changes, or a new parent is set, we will increase the change ID
    m_changeId++;
but there is also a more subtle place where we need to increase it.
What if the parent changes? Do we need to change our change ID then?
Yep, definitely.
How are we going to do that if parent can't inform its children of its own changes?
Once again it will be child's responsibility to ask its parent if it has changed.
At what point should it ask?
When asked for its changed ID, so in getChangeId()
For that we'll need to cache parent's change ID
    mutable unsigned m_cachedParentChangeId = 0;
More specifically this is the parent's change ID that has been last used for our own change ID.
Then in getChangeId() we can ask for parent's change ID and compare with our cached one.
If they are different we need to increase our change id, and cache the new parent's change ID
    if (m_parent != nullptr)
    {
        const unsigned parentChangeId = m_parent->getChangeId();
        if (m_cachedParentChangeId < parentChangeId)
        {
            m_cachedParentChangeId = parentChangeId;
            m_changeId++;
        }
    }
The logic here is a bit confusing, gotta admit,
because why are we checking for changes in parent only when we get asked for our change ID?
Is it not possible that parent will change many times between our getChangeId() calls?
Yes, it's 100% possible, but it's not a problem.
Imagine code A is some outside code that cares about our change ID.
At some point it will ask us:
    getChangeId()
and we will give it, let's say
    5
Then, our parent can change 10 times, and we will not react at all,
our internal change ID will still be 5, which may seem wrong.
But it's not.
Because later when we get asked for our change ID again
    getChangeId()
we will notice parent's change and we will increase our change ID to 6, and asnwer
    6
Then code A will notice that 5 < 6 and will react to a change.
Code A doesn't care if 1 change has occured in the meantime, or 10 changes, or whatever,
it just cares that a change occured.
So, as long as this change ID is used just to check for "is there a change?"
and NOT for "how many changes were there?" we're good.
Okay, now that we have a reliable change ID,
let's get back to the problem of checking if parent's world matrix has changed
since the last time we updated our world matrix.
We can very easily cache parent's change ID at the moment of calculating our world matrix in updateWorldMatrix()
in this new member variable:
    mutable unsigned m_parentChangeIdUsedInWorldMatrix = 0;
like this:
    m_parentChangeIdUsedInWorldMatrix = m_parent->getChangeId();
Then in getWorldMatrix() we need to check if parent's current change ID is greater than the cached one
    if (... && m_parentChangeIdUsedInWorldMatrix < m_parent->getChangeId())
and if so we need to mark world matrix as dirty:
    m_isDirtyWorldMatrix = true;
Oooookay, that's about it.
There are quite a few details that I'm missing but they are not that important.
This here is the gist of it.

Future note,
this whole optimization mess that I did might not actually be worth it.
It might have been better to keep a list of children in each parent
and inform children when a change occurs.
Because with the current approach we are still doing N recursive calls in getChangeId().
Yes, they are much simpler and they don't carry with themselves a matrix operation
but still - N recursive calls every time we want to get the world matrix of an object.
Can't really decide if wasting a bit of memory on a list of children
or wasting a bit of CPU cycles on N recursive calls is better.
I guess we'll see in the future, when we can test with a bigger scene.

Okay, it works!
And it's supposedly fast, we'll see in the future if we can make it even faster.
Done.
}
