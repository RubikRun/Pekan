0000 18.02.2025 (DONE): Add "m_" prefix to all private member variables

0001 18.02.2025 (DONE): Add comments on class PekanEngine and class PekanRenderer

0002 23.02.2025 (DONE): Create a base class RenderComponent with common functions and variables
                        between different OpenGL objects, for example Shader, VertexBuffer, VertexArray, etc.
                        All of them need to have create(), destroy(), bind(), unbind(), isValid(), id, etc.

0003 23.02.2025 (DONE): Provide optional parameter of create() function of VertexBuffer and IndexBuffer
                        for the value that is currently hardcoded as GL_STATIC_DRAW

0004 24.02.2025 (DONE): Wrap all OpenGL calls in an OpenGL error-checking macro

0005 24.02.2025 (DONE): In class PekanRenderer make all non-client functions be private, and allow usage for internal classes with "friend" keyword.

0006 24.02.2025 (DONE): Do some error-checking in most functions in OpenGL wrapper classes. Mostly check isValid() and bind().
                        Think about whether we want to do these checks in every function (secure, but may cost performance)

0007 01.03.2025 (DONE): Do we need to keep m_window as member of PekanGUIWindow when we already have a static s_window in PekanEngine?

0008 04.03.2025 (DONE): Add support for line numbers in log messages in PekanLogger

0009 19.03.2025 (DONE): Add option for changing window's title in applications

0010 20.03.2025 (DONE): Limit FPS

0011 21.03.2025 (DONE): Event system

0012 21.03.2025 (DONE): Provide a way for applications to specify their way of closing

0013 25.03.2025 (DONE): In Demo03 see what happens if window is resized during gameplay. My guess is snake's squares will not remain square.
                        Make them respond dynamically to window's resolution.
                        NOTE FROM FUTURE: Decided not to do that because Demo03 is full screen anyway, so resolution will not be changing.

0014 29.03.2025 (DONE): Create an ASSERT() mechanism

0015 03.04.2025 (DONE): Create an event queue so that events can be handled together at once, at a specific stage of the main loop.

0016 03.04.2025 (DONE): Create a Window class

0017 05.04.2025 (DONE): Create Pekan enums corresponding to event-related enums in GLFW, like GLFW_KEY_W

0018 11.04.2025 (DONE): Use PekanEngine's event polling on these 2 lines in PekanApplication.cpp
                            if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
                            glfwGetFramebufferSize(window, &windowWidth, &windowHeight);

0019 14.04.2025 (DONE): Create a way for derived applications to set up layer stack without directly touching
                        the member variable m_layerStack. Maybe add an output parameter to _init() function
                        that will be used by the base PekanApplication::init()

0020 25.04.2025 (DONE): Create a delta-time mechanism for FPS-independent movement

0021 15.05.2025 (DONE): Research glBufferSubData(). Decide if we need it in Pekan.

0022 15.05.2025 (DONE): In RenderObject's setVertexData() and setIndexData() functions do something so that client doesn't have to provide BufferDataUsage each time.
                        It should be optional.
                        If they don't provide a BufferDataUsage then the BufferDataUsage passed in the beggining to the create() function should be used.

0023 15.05.2025 (DONE): Create enums for parameters in class Texture

0024 17.05.2025 (DONE): Think about how many and which ones of the create() overloads in RenderObject we need.
                        I would say it's good to have create() overloads for combinations of the required components (vertices and shader)
                        but the optional components (indices and texture) should be set by explicitly calling a set*() function.

0025 17.05.2025 (DONE): Check what happens if you call setTextureImage() more than once on a single RenderObject

0026 20.05.2025 (DONE): Check if passing vertices to TriangleShape's create() in reverse order still works (change clockwise-ness of vertices).

0027 22.05.2025 (DONE): Think about using getVertexData() in createRenderObject() instead of having a vertexData parameter

0028 24.05.2025 (DONE): Think about the relationship between textures and a shader in RenderObject.
                        More specifically when client changes the shader in a RenderObject what should happen to the textures?
                        Currently they are just all deleted and client should set textures anew if they need them in the new shader.
                        Is this an okay behavior? Is there something else that can be done?

0029 25.05.2025 (DONE): What will happen if you call a create() function of a 2D shape more than once, without calling destroy() in between?

0030 27.05.2025 (DONE): Create a 2D camera that can be moved with mouse and/or with WASD keys

0031 27.05.2025 (DONE): Create a world space and a resolution-independent way to render 2D shapes

0032 28.05.2025 (DONE): Implement triangulation algorithm in PolygonShape to support non-convex polygons

0033 11.06.2025 (DONE): Add support for rotation of 2D shapes

0034 11.06.2025 (DONE): Think about maybe removing the overload of Shape::render() that doesn't take in a camera parameter

0035 15.06.2025 (DONE): Make CameraController2D zoom at the direction of the mouse instead of towards the center

0036 16.06.2025 (DONE): Add overload of Camera2D's setSize() function that takes in a single float - the scale,
                        and automatically calculates width and height with the same ratio as window's resolution.

0037 16.06.2025 (DONE): Fix bug in CameraController2D - when camera's size is different from window's resolution
                        the translation speed is wrong. We need to take into acount the ratio of camera's size to window's resolution.

0038 16.06.2025 (DONE): Fix bug with CameraController2D receiving events from ImGui layer.
                        For example, when you move an ImGui slider left and right, the camera behind it also moves left and right.

0039 25.06.2025 (DONE): Add "bool dynamic" parameter to create() functions of all shape types.
                        It should do the same as before. I just removed it for a bit while restructuring shape classes.

0040 30.06.2025 (DONE): Use a 1D texture for batch rendering of 2D shapes to pass colors to shader,
                        instead of having a color attribute on each vertex (wasteful for memory)

0041 01.07.2025 (DONE): Think about using more than 1 batch for batch rendering.
                        Maybe having some reasonable limit of vertices/indices per batch,
                        and when we reach it we can draw the batch and start a new one.

0042 03.07.2025 (DONE): Rename classes that have only pure virtual functions with the "I" prefix,
                        for example EventListener -> IEventListener

0043 05.07.2025 (DONE): Change core architecture so that window is not created by client code,
                        or think of something else. Maybe also move all OpenGL and window logic into Renderer instead of Core,
                        or better yet create a new module Graphics. Idk, many options, think about it.
                        Problem is there isn't a good moment to initialize Renderer2D.

0044 05.07.2025 (DONE): Why does this function in PekanEngine return a reference and not a const reference?
                            inline static Window& getWindow() { return s_window; }

0045 05.07.2025 (DONE): Fix Demo05 and Demo06, shapes are missing

0046 05.07.2025 (DONE): Remove
                            static glm::ivec2 getWindowSize();
                        from PekanEngine

0047 05.07.2025 (DONE): Think about moving ImGui to its own module and subsystem called GUI, instead of having it in Core.

0048 06.07.2025 (DONE): Rename project Renderer to Renderer2D. Let's have a single subsystem per module and their names to always match.

0049 07.07.2025 (DONE): Move numberOfSamples member from WindowProperties to ApplicationProperties

0050 12.07.2025 (DONE): Is it a problem that RenderObject and ShapesBatch might use the same texture slots?
                        Probably not, because they do separate draw calls and have separate shaders.
                        Still, good to check.

0051 12.07.2025 (DONE): Maybe rename the 2 shaders
                            2D_BatchRendering_VertexShader.glsl
                            SolidColor_BatchRendering_FragmentShader.glsl
                        into something reflecting that they are specifically for shapes.
                        Previously they were general-purpose - could be used for other objects as well,
                        but now they are specific to batched shapes.
                        If we use them for something else, it will probably be broken.
                        Check if that's the case.
                        If something is broken, we'll need to keep these 2 current shaders (but renamed)
                        and bring back their older version as well.

0052 20.07.2025 (DONE): Remove "inline" from some places

0053 24.07.2025 (DONE): Rename class GUI to GUISystem and class Graphics to GraphicsSystem.

0054 24.07.2025 (DONE): Create a mechanism in LayerStack (or elsewhere) that allows for client code to specify
                        a hierarchy of layer initialization (which layers should be initialized before which ones)

0055 25.07.2025 (DONE): Fix Demo06 to not crash if default shapes count is different than max shapes count.
                        Currently it just creates the default number of shapes at initialization time
                        and then if you increase them during runtime it crashes.

0056 25.07.2025 (DONE): Change class Layer's getName() function to be pure virtual and remove m_name member, maybe also remove constructor.

0057 01.08.2025 (DONE): Check if it's better/faster to pre-allocate a fixed-size vertex buffer in ShapesBatch
                        and use m_renderObject.setVertexSubData() instead of m_renderObject.setVertexData().
                        Then we'll have to start a new batch whenever we fill up the buffer, which is fine.

0058 03.08.2025 (DONE): Figure out order of rendering of shapes and sprites.
                        More specifically if you have both shapes and sprites in a single scene
                        then the whole shapes batch is rendered first and then the whole sprites batch is rendered second
                        disregarding the order in which client code called render() on their shapes and sprites.
                        Example: In Demo08 we render m_centerSquare after the sprites, but the sprites appear on top.

0059 07.08.2025 (DONE): Add API to class Sprite allowing sprite's texture to be changed after having created the sprite.

0060 07.08.2025 (DONE): Think about class Sprite's setTextureIndex() function and class Shape's setShapeIndex() function.
                        Do they need to be functions? Is it not bad that they can be called by other code except SpritesBatch and ShapesBatch?
                        We require them to be called before calling getVertices() so why don't we make this index be a parameter to getVertices() ?

0061 08.08.2025 (DONE): Get rid of code duplication in the 2 render() overloads in ShapesBatch, same way as it's done in SpritesBatch

0062 09.08.2025 (DONE): Do some error-checking in VertexBuffer's setSubData() and IndexBuffer's setSubData()

0063 12.08.2025 (DONE): Move class RenderObject to module Graphics

0064 14.08.2025 (DONE): Remove m_isDynamic member from class Shape and class Sprite. Make sure it's not used anywhere.

0065 15.08.2025 (DONE): Dynamically insert maximum number of textures supported on current hardware in the shaders
                            2D_Batch_1DTexture_FragmentShader.glsl
                            2D_Batch_FragmentShader.glsl
                        instead of having this 32 hardcoded:
                            #define MAX_TEXTURES 32

0066 14.09.2025 (DONE): Create a mechanism in Core where client code can register a callback function
                        to be called every N seconds automatically. Use it for Gleam House's updateFireColors() function, for example.

0067 14.09.2025 (DONE): Create a getRandomColor() overload in PekanUtils.h/cpp that takes in an RGB range where R, G and B's min/max can be different.

0068 19.09.2025 (DONE): Remove "static" from "static const" and "static constexpr" everywhere
                        where used for global variables that are constant, defined in a single .cpp, and not supposed to be visible outside.
                        It's redundant. Global constants have internal linkage by default.

0069 02.10.2025 (DONE): In Demo02_Scene.cpp call
                            RenderCommands::clear(true, true);
                        instead of
                            RenderCommands::clear(true);
                        because since the "Add support for post-processing shaders" commit this clear()
                        function does NOT clear depth buffer by default.

0070 17.10.2025 (DONE): Use
                            inline static const
                        everywhere to define static const member variables inside the class, instead of separately in the .cpp

0071 22.10.2025 (DONE): Call
                            RenderCommands::clear()
                        by default between frames in PekanApplication's run() function.
                        Example situation where this is needed: An application with a GUI window only,
                        without a scene - the window is not cleared automatically and the GUI window
                        leaves a trail behind it when moved. Of course, client code can clear window
                        in their GUI window's render() function but that's awkward and doesn't make much sense.
                        Better to let engine clear window by default between frames,
                        and expose an option for disabling this default behavior,
                        because some applications might want to control clearing more explicitly.

0072 23.10.2025 (TODO): Implement "dirty flag" optimization in TransformComponent2D or/and TransformSystem2D

0073 24.10.2025 (DONE): Rename Renderer2DSystem and other subsystem classes to avoid ambiguity with ECS systems.
                        If you rename to Renderer2D then think about namespace vs class name ambiguity.
                        (Everything in the Renderer2D subsystem is inside of namespace Renderer2D)

0074 25.10.2025 (TODO): Think about creating a render batch in Graphics that can be used for RenderObject,
                        and using that for RenderBatch2D.

0075 25.10.2025 (TODO): Integrate RenderBatch2D in ECS once we have Sprite rendering and Shape rendering in ECS.

0076 28.10.2025 (TODO): Think about using a 1D texture for ECS shapes, for example in
                            renderRectangleWithSolidColorMaterial()    (Renderer2DSystem_ECS.cpp)

0077 03.11.2025 (DONE): Better assert messages in *System.cpp files in Renderer2D

0078 03.11.2025 (DONE): Remove all single-instance APIs from all ECS systems.
                        For example getters and setters of a field of a single instance of a component.
                        If really needed those should be in the component struct itself.

0079 06.11.2025 (DONE): Switch to C++ 20 and remove getDefaultCamera() function from CameraSystem2D.cpp,
                        instead use designated initializers for initializing g_defaultCamera

0080 06.11.2025 (DONE): Replace comments longer than 3-4 lines with a note, like (*1), (*2), etc. as done in CameraController2D.cpp

0081 06.11.2025 (DONE): Add support for rotation in CameraComponent2D and/or CameraSystem2D

0082 08.11.2025 (DONE): Add support for parent-child hierarchies in TransformComponent2D and TransformSystem2D

0083 08.11.2025 (DONE): Think of an alternative to getMousePosition() from old Renderer2DSystem

0084 12.11.2025 (DONE): Shapes/sprites/lines that don't have a transform can be rendered by just not applying a transform to their local vertices.
                        If there is no camera in the scene, shapes/sprites/lines can still be rendered in the default [-1, 1] range.

0085 16.11.2025 (DONE): Rename GraphicsSystem's registerSubsystem() function to registerAsSubsystem().
                        Same for other subsystems.

0086 16.11.2025 (DONE): Think about
                            return false;
                        statements in PekanApplication's init() function.

0087 10.12.2025 (TODO): Why is application not terminated when user closes the window?

0088 16.12.2025 (TODO): Think about if we can use view instead of registry in situations like this:
                            auto view = registry.view<ComponentTypes...>();
                            for (auto entity : view)
                            {
                                renderFunction(registry, entity);
                            }
                        Once we narrow down the registry to a view can we use that view from there on?
                        Looks like sometimes yes, sometimes no.
                        In the case above - probably not - because renderFunction() needs the whole registry
                        in order to calculate world matrix correctly.
