----------
20.03.2025
----------

{
Today in Demo02 I implemented a basic 3D scene with a rotating cube.
Initially every side of the cube was a different fixed size.
Now I made it so that the 6 colors of the 6 sides can be controlled with 6 colors controls in GUI.

Also changed GUI's scale because everything felt a bit small.
I scaled up font size and widgets size.

Added a slider for cube's rotation, instead of animating the rotation over time.
Added a slider for camera's FOV (field of view) angle.
Added a slider for camera's distance to center.

Demo02 is done.
}

{
For Demo03 I want to create the classic snake game.
It will not have any GUI, and I want it to be full screen.
Currently we don't support applications without GUI, which is stupid tbh, let's change it.
In PekanApplication we should allow both applications without GUI and applications without a scene.

Now let's start with Demo03 by creating a skeleton without GUI, only a scene.

Let's see how we can make it full screen.

----------
21.03.2025
----------

First of all, the full-screen-ness will be a property of an application,
so we can add this protected member variable to PekanApplication
    bool m_isFullScreen = false;
The idea is that derived classes can set this variable in their _init() function,
and then PekanApplication will handle it.
How will it handle it?
Well, creating the window is PekanEngine's job so when PekanApplication calls PekanEngine::init()
it will have to provide the m_isFullScreen value as a parameter.
So let's add a parameter to PekanEngine::init()
    static bool init(bool fullScreen = false);
If the parameter is false we want PekanEngine to create the window normally, as before.
If the parameter is true we want to create a full screen "window" like that
    GLFWmonitor* primaryMonitor = glfwGetPrimaryMonitor();
    const GLFWvidmode* mode = glfwGetVideoMode(primaryMonitor);
    s_window = glfwCreateWindow(mode->width, mode->height, "Fullscreen Window", primaryMonitor, nullptr);
Okay, it works.

Now let's see how we can hide the cursor.
Same story as full screen. This time this is the line that actually hides the cursor
    glfwSetInputMode(s_window, GLFW_CURSOR, GLFW_CURSOR_HIDDEN);
and we have this member of PekanApplication
    bool m_shouldHideCursor = false;
Done.

Next thing is that I want the application to close when user presses the escape key.
We don't yet have an event system or anything like that so it'd be hard to do this properly at the moment.
I'll just make it so that all PekanApplication's close like that, with the escape key.
In the future we will have an event system and a way for each application to specify its way of closure.
This is how to do it inside of PekanApplication's run loop
    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
    {
        glfwSetWindowShouldClose(window, true);
    }
Done.

Now let's begin with the actual snake game.
The main object in the game will be, well, the snake.
What is the snake? It's N squares that move in a particular way.
When the snake eats an apple the squares become N+1.
To render N squares we need the usual setup of a VertexBuffer, VertexArray, IndexBuffer and Shader.
Let's create a class Snake that will hold these 4 RenderComponent's and handle the logic of moving and growing the snake.
As a first step, let's make it be 4 squares next to each other that don't move.
Done.

Now let's make the snake move.
Introducing this member variable in class Snake
    glm::ivec2 m_direction = { -1, 0 };
and using it in Snake::update() to move the snake.
However, the snake should not move every frame, instead it should move every F frames by 1 square.
We need chopped movement, not smooth.
For that, we'll add this member variable
    int m_frames = 0;
that keeps track of how many frames have been rendered so far.

----------
22.03.2025
----------

Then inside of Snake::update() we'll check if m_frames is divisible by 20. Instead of 20 let's add this new constant
    static const int MOVE_FRAMES = 20;
If it's divisible we'll move the snake by just changing the coordinates inside of m_vertices.
After changing the coordinates we need to update the vertex buffer with this new data, like that:
    m_vertexBuffer.setData(m_vertices.data(), m_vertices.size() * sizeof(float), BufferDataUsage::DynamicDraw);
That's it. The snake now moves left.
Done.

Next step is to allow user to control the snake's movement with WASD keys.
Since we don't have an event system yet, we cannot do this properly.
I'll do it in a temporary way by just adding these 4 functions to PekanEngine
    static bool isKeyPressed_W();
    static bool isKeyPressed_A();
    static bool isKeyPressed_S();
    static bool isKeyPressed_D();
Then in Snake::update() we need to check these 4 functions and set m_direction accordingly.
Now the snake moves and user can control it with WASD,
but it moves in a funny way, not how a snake is supposed to move.
The 4 squares remain horizontally next to each other and the whole snake moves up when user presses W.

Now to do the snake's movement correctly there are 2 options.
Let squares be the list of squares and N be the number of squares.
1. Set
        squares[N-1] = squares[N-2]
        squares[N-2] = squares[N-3]
        squares[N-3] = squares[N-4]
        ...
        squares[1] = squares[0]
        squares[0] += direction
2. Keep track of head's index and tail's index - headIdx, tailIdx
In the beginning headIdx = 0 and tailIdx = N-1.
Each time we move the snake we'll do this:
    squares[tailIdx] = squares[headIdx] + direction
    tailIdx = tailIdx - 1
    if tailIdx < 0:
        tailIdx = N-1

Oviously the second algorithm is more effecient, so I'll use that one.
Done.

Snake looks weird now because our window is rectangular, not square, so the squares of the snake are rectangles with the same aspect ratio.
Let's make the window square just to verify, and then I'll address this issue so that it works on every resolution.
Okay, yes, it works with a square window.

----------
25.03.2025
----------

Now let's make the squares be squares no matter the window's resolution.
For that, I'll add this new member variable in class Snake
    float m_aspectRatio = 0.0f;
that will be initialized like this
    m_aspectRatio = float(PekanEngine::getWindowWidth()) / float(PekanEngine::getWindowHeight());
and then everytime we set/get a Y coordinate we will multiply/divide it by that aspect ratio.
Done.
Now it works with any resolution.

Next thing to implement in the snake game would be to generate an apple on a random position.
For that we'll first need a random number generator.
I'll add these 2 functions in PekanUtils.h/cpp
    int getRandomInt(int min, int max);
    float getRandomFloat(float min, float max);
Tested them, seem to work.
Done.

}