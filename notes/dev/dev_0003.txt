----------
20.03.2025
----------

{
Today in Demo02 I implemented a basic 3D scene with a rotating cube.
Initially every side of the cube was a different fixed size.
Now I made it so that the 6 colors of the 6 sides can be controlled with 6 colors controls in GUI.

Also changed GUI's scale because everything felt a bit small.
I scaled up font size and widgets size.

Added a slider for cube's rotation, instead of animating the rotation over time.
Added a slider for camera's FOV (field of view) angle.
Added a slider for camera's distance to center.

Demo02 is done.
}

{
For Demo03 I want to create the classic snake game.
It will not have any GUI, and I want it to be full screen.
Currently we don't support applications without GUI, which is stupid tbh, let's change it.
In PekanApplication we should allow both applications without GUI and applications without a scene.

Now let's start with Demo03 by creating a skeleton without GUI, only a scene.

Let's see how we can make it full screen.

----------
21.03.2025
----------

First of all, the full-screen-ness will be a property of an application,
so we can add this protected member variable to PekanApplication
    bool m_isFullScreen = false;
The idea is that derived classes can set this variable in their _init() function,
and then PekanApplication will handle it.
How will it handle it?
Well, creating the window is PekanEngine's job so when PekanApplication calls PekanEngine::init()
it will have to provide the m_isFullScreen value as a parameter.
So let's add a parameter to PekanEngine::init()
    static bool init(bool fullScreen = false);
If the parameter is false we want PekanEngine to create the window normally, as before.
If the parameter is true we want to create a full screen "window" like that
    GLFWmonitor* primaryMonitor = glfwGetPrimaryMonitor();
    const GLFWvidmode* mode = glfwGetVideoMode(primaryMonitor);
    s_window = glfwCreateWindow(mode->width, mode->height, "Fullscreen Window", primaryMonitor, nullptr);
Okay, it works.

Now let's see how we can hide the cursor.
Same story as full screen. This time this is the line that actually hides the cursor
    glfwSetInputMode(s_window, GLFW_CURSOR, GLFW_CURSOR_HIDDEN);
and we have this member of PekanApplication
    bool m_shouldHideCursor = false;
Done.

Next thing is that I want the application to close when user presses the escape key.
We don't yet have an event system or anything like that so it'd be hard to do this properly at the moment.
I'll just make it so that all PekanApplication's close like that, with the escape key.
In the future we will have an event system and a way for each application to specify its way of closure.
This is how to do it inside of PekanApplication's run loop
    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
    {
        glfwSetWindowShouldClose(window, true);
    }
Done.

Now let's begin with the actual snake game.
The main object in the game will be, well, the snake.
What is the snake? It's N squares that move in a particular way.
When the snake eats an apple the squares become N+1.
To render N squares we need the usual setup of a VertexBuffer, VertexArray, IndexBuffer and Shader.
Let's create a class Snake that will hold these 4 RenderComponent's and handle the logic of moving and growing the snake.
As a first step, let's make it be 4 squares next to each other that don't move.
Done.

Now let's make the snake move.
Introducing this member variable in class Snake
    glm::ivec2 m_direction = { -1, 0 };
and using it in Snake::update() to move the snake.
However, the snake should not move every frame, instead it should move every F frames by 1 square.
We need chopped movement, not smooth.
For that, we'll add this member variable
    int m_frames = 0;
that keeps track of how many frames have been rendered so far.

----------
22.03.2025
----------

Then inside of Snake::update() we'll check if m_frames is divisible by 20. Instead of 20 let's add this new constant
    static const int MOVE_FRAMES = 20;
If it's divisible we'll move the snake by just changing the coordinates inside of m_vertices.
After changing the coordinates we need to update the vertex buffer with this new data, like that:
    m_vertexBuffer.setData(m_vertices.data(), m_vertices.size() * sizeof(float), BufferDataUsage::DynamicDraw);
That's it. The snake now moves left.
Done.

}